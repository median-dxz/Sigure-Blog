diff --git a/dist/midori.cjs b/dist/midori.cjs
index 492b0d792d15f1bf7b85dfaaa61128a797a0381a..5b9a763956f3c9451575c122eb0cfc7378c6a0f0 100644
--- a/dist/midori.cjs
+++ b/dist/midori.cjs
@@ -1,2 +1,512 @@
-(()=>{"use strict";var t={d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function i(t,e){if(null==t)return{};var i,n,o=function(t,e){if(null==t)return{};var i,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||(o[i]=t[i]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(o[i]=t[i])}return o}function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function r(t,e,i){return e&&o(t.prototype,e),i&&o(t,i),Object.defineProperty(t,"prototype",{writable:!1}),t}function s(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}t.r(e),t.d(e,{Background:()=>dt,BackgroundCamera:()=>k,BackgroundEffects:()=>ft,BackgroundRenderer:()=>Mt,Easings:()=>Et,EffectPass:()=>ut,EffectType:()=>X,Particles:()=>ht,SlideDirection:()=>mt,TransitionType:()=>gt,WipeDirection:()=>vt,isWebGLSupported:()=>Dt,loadImage:()=>Tt});const a=require("three"),u=require("three/examples/jsm/postprocessing/EffectComposer"),f=require("three/examples/jsm/WebGL");var c,l={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){var e=1.70158;return t*t*((e+1)*t-e)},Out:function(t){var e=1.70158;return--t*t*((e+1)*t+e)+1},InOut:function(t){var e=2.5949095;return(t*=2)<1?t*t*((e+1)*t-e)*.5:.5*((t-=2)*t*((e+1)*t+e)+2)}},Bounce:{In:function(t){return 1-l.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*l.Bounce.In(2*t):.5*l.Bounce.Out(2*t-1)+.5}}},h="undefined"==typeof self&&"undefined"!=typeof process&&process.hrtime?function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof self&&void 0!==self.performance&&void 0!==self.performance.now?self.performance.now.bind(self.performance):void 0!==Date.now?Date.now:function(){return(new Date).getTime()},d=function(){function t(){this._tweens={},this._tweensAddedDuringUpdate={}}return t.prototype.getAll=function(){var t=this;return Object.keys(this._tweens).map((function(e){return t._tweens[e]}))},t.prototype.removeAll=function(){this._tweens={}},t.prototype.add=function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},t.prototype.remove=function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},t.prototype.update=function(t,e){void 0===t&&(t=h()),void 0===e&&(e=!1);var i=Object.keys(this._tweens);if(0===i.length)return!1;for(;i.length>0;){this._tweensAddedDuringUpdate={};for(var n=0;n<i.length;n++){var o=this._tweens[i[n]],r=!e;o&&!1===o.update(t,r)&&!e&&delete this._tweens[i[n]]}i=Object.keys(this._tweensAddedDuringUpdate)}return!0},t}(),v={Linear:function(t,e){var i=t.length-1,n=i*e,o=Math.floor(n),r=v.Utils.Linear;return e<0?r(t[0],t[1],n):e>1?r(t[i],t[i-1],i-n):r(t[o],t[o+1>i?i:o+1],n-o)},Bezier:function(t,e){for(var i=0,n=t.length-1,o=Math.pow,r=v.Utils.Bernstein,s=0;s<=n;s++)i+=o(1-e,n-s)*o(e,s)*t[s]*r(n,s);return i},CatmullRom:function(t,e){var i=t.length-1,n=i*e,o=Math.floor(n),r=v.Utils.CatmullRom;return t[0]===t[i]?(e<0&&(o=Math.floor(n=i*(1+e))),r(t[(o-1+i)%i],t[o],t[(o+1)%i],t[(o+2)%i],n-o)):e<0?t[0]-(r(t[0],t[0],t[1],t[1],-n)-t[0]):e>1?t[i]-(r(t[i],t[i],t[i-1],t[i-1],n-i)-t[i]):r(t[o?o-1:0],t[o],t[i<o+1?i:o+1],t[i<o+2?i:o+2],n-o)},Utils:{Linear:function(t,e,i){return(e-t)*i+t},Bernstein:function(t,e){var i=v.Utils.Factorial;return i(t)/i(e)/i(t-e)},Factorial:(c=[1],function(t){var e=1;if(c[t])return c[t];for(var i=t;i>1;i--)e*=i;return c[t]=e,e}),CatmullRom:function(t,e,i,n,o){var r=.5*(i-t),s=.5*(n-e),a=o*o;return(2*e-2*i+r+s)*(o*a)+(-3*e+3*i-2*r-s)*a+r*o+e}}},p=function(){function t(){}return t.nextId=function(){return t._nextId++},t._nextId=0,t}(),m=new d,_=function(){function t(t,e){void 0===e&&(e=m),this._object=t,this._group=e,this._isPaused=!1,this._pauseStart=0,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._initialRepeat=0,this._repeat=0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,this._startTime=0,this._easingFunction=l.Linear.None,this._interpolationFunction=v.Linear,this._chainedTweens=[],this._onStartCallbackFired=!1,this._id=p.nextId(),this._isChainStopped=!1,this._goToEnd=!1}return t.prototype.getId=function(){return this._id},t.prototype.isPlaying=function(){return this._isPlaying},t.prototype.isPaused=function(){return this._isPaused},t.prototype.to=function(t,e){return this._valuesEnd=Object.create(t),void 0!==e&&(this._duration=e),this},t.prototype.duration=function(t){return this._duration=t,this},t.prototype.start=function(t){if(this._isPlaying)return this;if(this._group&&this._group.add(this),this._repeat=this._initialRepeat,this._reversed)for(var e in this._reversed=!1,this._valuesStartRepeat)this._swapEndStartRepeatValues(e),this._valuesStart[e]=this._valuesStartRepeat[e];return this._isPlaying=!0,this._isPaused=!1,this._onStartCallbackFired=!1,this._isChainStopped=!1,this._startTime=void 0!==t?"string"==typeof t?h()+parseFloat(t):t:h(),this._startTime+=this._delayTime,this._setupProperties(this._object,this._valuesStart,this._valuesEnd,this._valuesStartRepeat),this},t.prototype._setupProperties=function(t,e,i,n){for(var o in i){var r=t[o],s=Array.isArray(r),a=s?"array":typeof r,u=!s&&Array.isArray(i[o]);if("undefined"!==a&&"function"!==a){if(u){var f=i[o];if(0===f.length)continue;f=f.map(this._handleRelativeValue.bind(this,r)),i[o]=[r].concat(f)}if("object"!==a&&!s||!r||u)void 0===e[o]&&(e[o]=r),s||(e[o]*=1),n[o]=u?i[o].slice().reverse():e[o]||0;else{for(var c in e[o]=s?[]:{},r)e[o][c]=r[c];n[o]=s?[]:{},this._setupProperties(r,e[o],i[o],n[o])}}}},t.prototype.stop=function(){return this._isChainStopped||(this._isChainStopped=!0,this.stopChainedTweens()),this._isPlaying?(this._group&&this._group.remove(this),this._isPlaying=!1,this._isPaused=!1,this._onStopCallback&&this._onStopCallback(this._object),this):this},t.prototype.end=function(){return this._goToEnd=!0,this.update(1/0),this},t.prototype.pause=function(t){return void 0===t&&(t=h()),this._isPaused||!this._isPlaying||(this._isPaused=!0,this._pauseStart=t,this._group&&this._group.remove(this)),this},t.prototype.resume=function(t){return void 0===t&&(t=h()),this._isPaused&&this._isPlaying?(this._isPaused=!1,this._startTime+=t-this._pauseStart,this._pauseStart=0,this._group&&this._group.add(this),this):this},t.prototype.stopChainedTweens=function(){for(var t=0,e=this._chainedTweens.length;t<e;t++)this._chainedTweens[t].stop();return this},t.prototype.group=function(t){return this._group=t,this},t.prototype.delay=function(t){return this._delayTime=t,this},t.prototype.repeat=function(t){return this._initialRepeat=t,this._repeat=t,this},t.prototype.repeatDelay=function(t){return this._repeatDelayTime=t,this},t.prototype.yoyo=function(t){return this._yoyo=t,this},t.prototype.easing=function(t){return this._easingFunction=t,this},t.prototype.interpolation=function(t){return this._interpolationFunction=t,this},t.prototype.chain=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return this._chainedTweens=t,this},t.prototype.onStart=function(t){return this._onStartCallback=t,this},t.prototype.onUpdate=function(t){return this._onUpdateCallback=t,this},t.prototype.onRepeat=function(t){return this._onRepeatCallback=t,this},t.prototype.onComplete=function(t){return this._onCompleteCallback=t,this},t.prototype.onStop=function(t){return this._onStopCallback=t,this},t.prototype.update=function(t,e){if(void 0===t&&(t=h()),void 0===e&&(e=!0),this._isPaused)return!0;var i,n,o=this._startTime+this._duration;if(!this._goToEnd&&!this._isPlaying){if(t>o)return!1;e&&this.start(t)}if(this._goToEnd=!1,t<this._startTime)return!0;!1===this._onStartCallbackFired&&(this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),n=(t-this._startTime)/this._duration,n=0===this._duration||n>1?1:n;var r=this._easingFunction(n);if(this._updateProperties(this._object,this._valuesStart,this._valuesEnd,r),this._onUpdateCallback&&this._onUpdateCallback(this._object,n),1===n){if(this._repeat>0){for(i in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat)this._yoyo||"string"!=typeof this._valuesEnd[i]||(this._valuesStartRepeat[i]=this._valuesStartRepeat[i]+parseFloat(this._valuesEnd[i])),this._yoyo&&this._swapEndStartRepeatValues(i),this._valuesStart[i]=this._valuesStartRepeat[i];return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,this._onRepeatCallback&&this._onRepeatCallback(this._object),!0}this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var s=0,a=this._chainedTweens.length;s<a;s++)this._chainedTweens[s].start(this._startTime+this._duration);return this._isPlaying=!1,!1}return!0},t.prototype._updateProperties=function(t,e,i,n){for(var o in i)if(void 0!==e[o]){var r=e[o]||0,s=i[o],a=Array.isArray(t[o]),u=Array.isArray(s);!a&&u?t[o]=this._interpolationFunction(s,n):"object"==typeof s&&s?this._updateProperties(t[o],r,s,n):"number"==typeof(s=this._handleRelativeValue(r,s))&&(t[o]=r+(s-r)*n)}},t.prototype._handleRelativeValue=function(t,e){return"string"!=typeof e?e:"+"===e.charAt(0)||"-"===e.charAt(0)?t+parseFloat(e):parseFloat(e)},t.prototype._swapEndStartRepeatValues=function(t){var e=this._valuesStartRepeat[t],i=this._valuesEnd[t];this._valuesStartRepeat[t]="string"==typeof i?this._valuesStartRepeat[t]+parseFloat(i):this._valuesEnd[t],this._valuesEnd[t]=e},t}(),g=(p.nextId,m),y=(g.getAll.bind(g),g.removeAll.bind(g),g.add.bind(g),g.remove.bind(g),g.update.bind(g));function b(t,e){return 2*Math.tan(a.MathUtils.degToRad(e.fov)/2)*t}function x(t,e){return b(t,e)*e.aspect}function w(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=t>=e,o=n?t:e,r=n?e:t,s=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));if(r<=2*s*a*o||Math.abs(s-a)<1e-10){var u=.5*r;return{width:n?u/s:u/a,height:n?u/a:u/s}}var f=a*a-s*s;return{width:(t*a-e*s)/f,height:(e*a-t*s)/f}}function S(t,e,i){var n=t.geometry.parameters,o=w(n.width,n.height,i),r=o.width,s=o.height,u=2*Math.tan(a.MathUtils.degToRad(e.fov)/2),f=r/(u*e.aspect),c=s/u;return Math.min(f,c)+t.position.z}function U(t,e,i){return Math.max(Math.min(t,i),e)}var k=function(){function t(e,i,o){n(this,t),s(this,"_plane",void 0),s(this,"camera",void 0),s(this,"_position",new a.Vector4(0,0,1,0)),s(this,"_positionOffset",new a.Vector4(0,0,0,0)),s(this,"_positionWithOffset",this._position.clone()),s(this,"_positionTransition",new _({x:0,y:0,z:0})),s(this,"_rotationTransition",new _({zr:0})),s(this,"_swayOffset",new a.Vector4(0,0,0,0)),s(this,"_swayTransition",new _({offsetX:0,offsetY:0,offsetZ:0,offsetZR:0})),this._plane=e,this.camera=new a.PerspectiveCamera(35,i/o,.001)}return r(t,[{key:"position",get:function(){var t=this._position;return{x:t.x,y:t.y,z:t.z,zr:t.w}}},{key:"positionOffset",get:function(){var t=this._positionOffset;return{x:t.x,y:t.y,z:t.z,zr:t.w}}},{key:"isMoving",value:function(){return this._positionTransition.isPlaying()}},{key:"isRotating",value:function(){return this._rotationTransition.isPlaying()}},{key:"isSwaying",value:function(){return this._swayTransition.isPlaying()}},{key:"setSize",value:function(t,e){this.camera.aspect=t/e,this.camera.updateProjectionMatrix()}},{key:"offset",value:function(t){var e=t.x,i=void 0===e?0:e,n=t.y,o=void 0===n?0:n,r=t.z,s=void 0===r?0:r,a=t.zr,u=void 0===a?0:a;this._positionOffset.set(i,o,s,u)}},{key:"sway",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("boolean"!=typeof t){this._swayTransition.stop();var n=i.loop,o=void 0!==n&&n,r=i.duration,s=void 0===r?0:r,u=i.delay,f=void 0===u?0:u,c=i.easing,h=void 0===c?l.Linear.None:c,d=i.onInit,v=void 0===d?function(){return{}}:d,p=i.onStart,m=void 0===p?function(){return{}}:p,g=i.onUpdate,y=void 0===g?function(){return{}}:g,b=i.onComplete,x=void 0===b?function(){return{}}:b,w=i.onStop,S=void 0===w?function(){return{}}:w,k=t.x,O=void 0===k?0:k,P=t.y,D=void 0===P?0:P,T=t.z,M=void 0===T?0:T,E=t.zr,B=void 0===E?0:E,z=a.MathUtils.degToRad(B),R=U(this._position.x+this._positionOffset.x,0,1),C=Math.max(0,R-O),A=Math.min(1,R+O),j=A-C,F=C+j*Math.random()-R,I=U(this._position.y+this._positionOffset.y,0,1),V=Math.max(0,I-D),L=Math.min(1,I+D),W=L-V,G=V+W*Math.random()-I,N=U(this._position.z+this._positionOffset.z,0,1),q=Math.max(0,N-M),X=Math.min(1,N+M),Y=X-q,Z=q+Y*Math.random()-N;v(),this._swayTransition=new _({offsetX:this._swayOffset.x,offsetY:this._swayOffset.y,offsetZ:this._swayOffset.z,offsetZR:this._swayOffset.w}).to({offsetX:F,offsetY:G,offsetZ:Z,offsetZR:-z+Math.random()*z*2},1e3*s).easing(h).onStart(m).onUpdate((function(t){var i=t.offsetX,n=t.offsetY,o=t.offsetZ,r=t.offsetZR;e._swayOffset.set(i,n,o,r),y()})).onComplete((function(){o&&e.sway(t,i),x()})).onStop(S).delay(1e3*f).start()}else t||this._swayTransition.stop()}},{key:"rotate",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("boolean"!=typeof t){this._rotationTransition.stop();var n=i.duration,o=void 0===n?0:n,r=i.delay,s=void 0===r?0:r,u=i.easing,f=void 0===u?l.Linear.None:u,c=i.onInit,h=void 0===c?function(){return{}}:c,d=i.onStart,v=void 0===d?function(){return{}}:d,p=i.onUpdate,m=void 0===p?function(){return{}}:p,g=i.onComplete,y=void 0===g?function(){return{}}:g,b=i.onStop,x=void 0===b?function(){return{}}:b,w=a.MathUtils.degToRad(t);h(),o>0||s>0?this._rotationTransition=new _({zr:this._position.w}).to({zr:w},1e3*o).easing(f).onStart(v).onUpdate((function(t){var i=t.zr;e._position.set(e._position.x,e._position.y,e._position.z,i),m()})).onComplete(y).onStop(x).delay(1e3*s).start():this._position.set(this._position.x,this._position.y,this._position.z,w)}else t||this._rotationTransition.stop()}},{key:"move",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("boolean"!=typeof t){this._positionTransition.stop();var n=this._position,o=n.x,r=n.y,s=n.z,a=t.x,u=void 0===a?o:a,f=t.y,c=void 0===f?r:f,h=t.z,d=void 0===h?s:h,v=i.duration,p=void 0===v?0:v,m=i.delay,g=void 0===m?0:m,y=i.easing,b=void 0===y?l.Linear.None:y,x=i.onInit,w=void 0===x?function(){return{}}:x,S=i.onStart,U=void 0===S?function(){return{}}:S,k=i.onUpdate,O=void 0===k?function(){return{}}:k,P=i.onComplete,D=void 0===P?function(){return{}}:P,T=i.onStop,M=void 0===T?function(){return{}}:T;w(),p>0||g>0?this._positionTransition=new _({x:o,y:r,z:s}).to({x:u,y:c,z:d},1e3*p).easing(b).onStart(U).onUpdate((function(t){var i=t.x,n=t.y,o=t.z;e._position.set(i,n,o,e._position.w),O()})).onComplete(D).onStop(M).delay(1e3*g).start():this._position.set(u,c,d,this._position.w)}else t||this._positionTransition.stop()}},{key:"update",value:function(){var t=this._positionWithOffset.z/S(this._plane,this.camera,this.camera.rotation.z);this._positionWithOffset.set(U(this._position.x+this._positionOffset.x+this._swayOffset.x*t,0,1),U(this._position.y+this._positionOffset.y+this._swayOffset.y*t,0,1),U(.9*(this._position.z+this._positionOffset.z+this._swayOffset.z)+(1-.9),0,1),this._position.w+a.MathUtils.degToRad(this._positionOffset.w)+this._swayOffset.w);var e=function(t,e,i){var n=i.x,o=i.y,r=i.z,s=i.w,u=function(t,e,i,n){var o=t.geometry.parameters,r=w(o.width,o.height,n),s=r.width,a=r.height,u=function(t,e,i,n){var o=i*S(t,e,n);return{width:x(o,e),height:b(o,e)}}(t,e,i,n);return{width:s-u.width,height:a-u.height}}(t,e,r,s),f=-u.width/2+n*u.width,c=u.height/2-o*u.height,l=S(t,e,s)*r;return new a.Vector4(f*Math.cos(s)-c*Math.sin(s),f*Math.sin(s)+c*Math.cos(s),l,s)}(this._plane,this.camera,this._positionWithOffset),i=e.x,n=e.y,o=e.z;this.camera.position.set(i,n,o),this.camera.rotation.z=this._position.w+a.MathUtils.degToRad(this._positionOffset.w)+this._swayOffset.w}},{key:"dispose",value:function(){this.sway(!1),this.move(!1),this.rotate(!1)}}]),t}();function O(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function P(t){return P=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},P(t)}function D(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=P(t)););return t}function T(){return T="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,i){var n=D(t,e);if(n){var o=Object.getOwnPropertyDescriptor(n,e);return o.get?o.get.call(arguments.length<3?t:i):o.value}},T.apply(this,arguments)}function M(t,e){return M=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},M(t,e)}function E(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&M(t,e)}function B(t){return B="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},B(t)}function z(t,e){if(e&&("object"===B(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return O(t)}function R(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}const C=require("three/examples/jsm/postprocessing/Pass"),A=require("three/examples/jsm/shaders/CopyShader"),j=require("three/examples/jsm/shaders/BlendShader");var F=Object.freeze({HORIZONTAL:[1,0],VERTICAL:[0,1]}),I={uniforms:{tDiffuse:{value:null},radius:{value:1},resolution:{value:0},direction:{value:[0,0]}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    uniform sampler2D tDiffuse;\n    uniform float radius;\n    uniform float resolution;\n    uniform vec2 direction;\n    varying vec2 vUv;\n\n    void main() {\n      float blur = radius / resolution;\n      float h = direction.x;\n      float v = direction.y;\n\n      vec4 sum = vec4(0.0);\n\n      // optimized 33-tap filter that takes advantage of bilinear filtering (effectively 17 fetches)\n      sum += texture2D(tDiffuse, vec2(vUv.x - 15.0810810809 * blur * h, vUv.y - 15.0810810809 * blur * v)) * 1.13068382e-7;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 13.1351352551 * blur * h, vUv.y - 13.1351352551 * blur * v)) * 0.00000634313;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 11.1891891693 * blur * h, vUv.y - 11.1891891693 * blur * v)) * 0.00014981883;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 9.2432432422 * blur * h, vUv.y - 9.2432432422 * blur * v)) * 0.00181031093;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 7.29729729717 * blur * h, vUv.y - 7.29729729717 * blur * v)) * 0.01244177332;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 5.35135135135 * blur * h, vUv.y - 5.35135135135 * blur * v)) * 0.0518407222;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 3.40540540538 * blur * h, vUv.y - 3.40540540538 * blur * v)) * 0.13626704123;\n      sum += texture2D(tDiffuse, vec2(vUv.x - 1.45945945945 * blur * h, vUv.y - 1.45945945945 * blur * v)) * 0.23145357738;\n\n      sum += texture2D(tDiffuse, vUv) * 0.13206059971;\n\n      sum += texture2D(tDiffuse, vec2(vUv.x + 1.45945945945 * blur * h, vUv.y + 1.45945945945 * blur * v)) * 0.23145357738;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 3.40540540538 * blur * h, vUv.y + 3.40540540538 * blur * v)) * 0.13626704123;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 5.35135135135 * blur * h, vUv.y + 5.35135135135 * blur * v)) * 0.0518407222;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 7.29729729717 * blur * h, vUv.y + 7.29729729717 * blur * v)) * 0.01244177332;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 9.2432432422 * blur * h, vUv.y + 9.2432432422 * blur * v)) * 0.00181031093;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 11.1891891693 * blur * h, vUv.y + 11.1891891693 * blur * v)) * 0.00014981883;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 13.1351352551 * blur * h, vUv.y + 13.1351352551 * blur * v)) * 0.00000634313;\n      sum += texture2D(tDiffuse, vec2(vUv.x + 15.0810810809 * blur * h, vUv.y + 15.0810810809 * blur * v)) * 1.13068382e-7;\n\n      gl_FragColor = sum;\n    }\n  "};const V=require("three/examples/jsm/shaders/RGBShiftShader"),L=require("three/examples/jsm/shaders/VignetteShader");var W={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},size:{value:1}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n    uniform float size;\n    varying vec2 vUv;\n\n    void main() {\n      vec2 uv = (vUv - vec2(0.5));\n      float mixRatio = smoothstep(0.0, 1.0, min(dot(uv, uv) * size, 1.0));\n      gl_FragColor = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), mixRatio);\n    }\n\n  "},G={uniforms:{tDiffuse:{value:null},tDepth:{value:null},clipToWorldMatrix:{value:new a.Matrix4},prevWorldToClipMatrix:{value:new a.Matrix4},intensity:{value:1},samples:{value:32}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    const int MAX_SAMPLES = 128;\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n    uniform mat4 clipToWorldMatrix;\n    uniform mat4 prevWorldToClipMatrix;\n    uniform float intensity;\n    uniform int samples;\n    varying vec2 vUv;\n\n    void main() {\n      float zOverW = texture2D(tDepth, vUv).x;\n      vec4 clipPosition = vec4(vUv.x, vUv.y, zOverW, 1.0);\n      vec4 worldPosition = clipToWorldMatrix * clipPosition;\n      worldPosition /= worldPosition.w;\n\n      vec4 prevClipPosition = prevWorldToClipMatrix * worldPosition;\n      prevClipPosition /= prevClipPosition.w;\n      vec2 velocity = ((clipPosition - prevClipPosition).xy + (clipPosition - prevClipPosition).zz) * intensity;\n\n      vec4 texel = texture2D(tDiffuse, vUv);\n      vec2 texelCoord = vUv;\n      for (int i = 1; i < MAX_SAMPLES; ++i) {\n        if (i >= samples) {\n          // hack to allow loop comparisons against uniforms\n          break;\n        }\n        // this offset calculation centers the blur which avoids unevenness favoring the direction of the velocity\n        vec2 offset = velocity * (float(i) / float(samples - 1) - 0.5);\n        texel += texture2D(tDiffuse, vUv + offset);\n      }\n\n      gl_FragColor = texel / max(1.0, float(samples));\n    }\n\n  "},N={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},resolution:{value:null},amount:{value:0},seed:{value:1}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    ".concat("\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                    -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n","\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n    uniform float amount;\n    uniform float seed;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n\n    vec2 tile(vec2 position, vec2 resolution, float size, float scale) {\n      vec2 tileSize = vec2(size / resolution.x * scale, size / resolution.y);\n      return tileSize * floor(position / tileSize);\n    }\n\n    float glitchNoise(vec2 position, vec2 resolution, float amount, float seed) {\n      // the amount affects the seeds used for noise and the multipliers for each type of glitch\n      float noise = 0.0;\n\n      // large rectangular glitch blocks\n      noise += max(snoise(tile(position, resolution, 488.0, 15.0) * (1.0 + amount * seed * 8.0)) * amount - 0.5, 0.0);\n\n      // medium square glitch blocks\n      noise += max(snoise(tile(position, resolution, 100.0, 1.0) * (4.0 + amount * seed * 2.0)) * amount - 0.3, 0.0);\n\n      // medium rectangular glitch blocks\n      noise += max(snoise(tile(position, resolution, 120.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);\n      noise += max(snoise(tile(position, resolution, 125.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);\n\n      // small rectangular glitch blocks\n      noise += max(snoise(tile(position, resolution, 29.0, 16.0) * (4.0 + amount * seed * 2.0)) * amount - 0.2, 0.0);\n\n      // small square glitch blocks\n      noise += max(snoise(tile(position, resolution, 29.0, 1.0) * (8.0 + amount * seed * 2.0)) * amount - 0.7, 0.0);\n\n      if (noise >= 0.6) {\n        // thin glitch lines - fill existing glitch blocks\n        noise += max(snoise(tile(position, resolution, 1.1, 1000.0) * 1000.0) * amount, 0.0);\n      } else if (noise <= 0.0) {\n        // thin glitch lines - fill remaining empty space\n        float lineNoise = max(snoise(tile(position, resolution, 1.1, 500.0) * (500.0 + amount * seed * 100.0)) * amount, 0.0);\n        lineNoise += min(snoise(tile(position, resolution, 100.0, 3.0) * (4.0 + amount * seed * 2.0)) * amount, 0.0);\n        noise += max(lineNoise, 0.0);\n      }\n\n      // coerce to max glitch amount\n      float glitchCoerceThreshold = 0.9;\n      if (amount >= glitchCoerceThreshold) {\n        float percent = (amount - glitchCoerceThreshold) / (1.0 - glitchCoerceThreshold);\n        return noise + (1.0 * percent);\n      }\n\n      return noise;\n    }\n\n    vec4 rgbShift(sampler2D tex, vec2 position, vec3 offset) {\n      vec4 r = texture2D(tex, position + vec2(offset.r, 0.0));\n      vec4 g = texture2D(tex, position + vec2(offset.g, 0.0));\n      vec4 b = texture2D(tex, position + vec2(offset.b, 0.0));\n      return vec4(r.r, g.g, b.b, 1.0);\n    }\n\n    void main() {\n      float glitch = glitchNoise(vUv, resolution, amount, seed);\n\n      vec3 rgbShiftOffset = vec3(0.01, 0.0, -0.01);\n      vec4 texel1 = texture2D(tDiffuse1, vUv);\n      vec4 shiftedTexel1 = rgbShift(tDiffuse1, vUv, rgbShiftOffset);\n      vec4 texel2 = texture2D(tDiffuse2, vUv);\n      vec4 shiftedTexel2 = rgbShift(tDiffuse2, vUv, rgbShiftOffset);\n\n      vec4 color = texel1;\n      if (glitch >= 0.95) {\n        // no glitching\n        color = texel2;\n      } else if (glitch >= 0.7) {\n        // color-shifted new texture\n        color = shiftedTexel2;\n      } else if (glitch >= 0.6) {\n        // color-shifted original texture\n        color = shiftedTexel1;\n      } else if (glitch >= 0.5) {\n        // magenta glitch blocks\n        color = texel1 * vec4(1.2, 0.0, 1.2, 0.5);\n      } else if (glitch >= 0.4) {\n        // cyan glitch blocks\n        color = texel1 * vec4(0.0, 1.2, 1.2, 0.5);\n      } else if (glitch >= 0.38) {\n        // bright color-shifted new texture\n        color = shiftedTexel2 * 1.5;\n      } else if (glitch >= 0.2) {\n        // color-shifted original texture\n        color = shiftedTexel1;\n      }\n\n      gl_FragColor = color;\n    }\n\n  ")};function q(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(var i in e){if(void 0===t.uniforms[i])throw new Error('Uniform "'.concat(i,'" does not exist on shader "').concat(t.name,'"'));t.uniforms[i].value=e[i]}}var X,Y={getUniforms:function(t){var e={};for(var i in t.uniforms)e[i]=t.uniforms[i].value;return e},updateUniforms:q,clearUniforms:function(t){t.uniforms=a.UniformsUtils.clone(t.uniforms)},createShaderMaterial:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=new a.ShaderMaterial({uniforms:a.UniformsUtils.clone(t.uniforms),vertexShader:t.vertexShader,fragmentShader:t.fragmentShader});return q(i,e),i}},Z=["opacity"],H=["size"];function Q(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=P(t);if(e){var o=P(this).constructor;i=Reflect.construct(n,arguments,o)}else i=n.apply(this,arguments);return z(this,i)}}function $(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function J(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?$(Object(i),!0).forEach((function(e){s(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):$(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}!function(t){t.Blur="Blur",t.Bloom="Bloom",t.RgbShift="RgbShift",t.Vignette="Vignette",t.VignetteBlur="VignetteBlur",t.MotionBlur="MotionBlur",t.Glitch="Glitch"}(X||(X={}));var K=function(){function t(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(this,t),s(this,"_quad",new C.FullScreenQuad),this._quad.material=Y.createShaderMaterial(e,i)}return r(t,[{key:"getUniforms",value:function(){return Y.getUniforms(this._quad.material)}},{key:"updateUniforms",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Y.updateUniforms(this._quad.material,t)}},{key:"clearUniforms",value:function(){Y.clearUniforms(this._quad.material)}},{key:"render",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t.setRenderTarget(e),this.updateUniforms(J(J({},n),{},{tDiffuse:i.texture})),this._quad.render(t)}},{key:"dispose",value:function(){this._quad.material.dispose()}}]),t}(),tt=function(t){E(i,t);var e=Q(i);function i(){return n(this,i),e.apply(this,arguments)}return r(i,[{key:"render",value:function(t,e,i,n){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};t.setRenderTarget(e),this.updateUniforms(J(J({},o),{},{tDiffuse1:i.texture,tDiffuse2:n.texture})),this._quad.render(t)}}]),i}(K),et=function(t){E(i,t);var e=Q(i);function i(t,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n(this,i),s(O(r=e.call(this,G,a)),"camera",void 0),s(O(r),"depthTexture",void 0),r.camera=t,r.depthTexture=o,r}return r(i,[{key:"render",value:function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=this.getUniforms(),s=r.clipToWorldMatrix,a=r.prevWorldToClipMatrix;T(P(i.prototype),"render",this).call(this,t,e,n,J(J({},o),{},{tDepth:this.depthTexture,clipToWorldMatrix:s.copy(this.camera.projectionMatrixInverse).multiply(this.camera.matrixWorld)})),a.copy(this.camera.matrixWorldInverse).multiply(this.camera.projectionMatrix)}}]),i}(K),it=function(t){E(i,t);var e=Q(i);function i(t,o){var r,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n(this,i),s(O(r=e.call(this,I,u)),"_width",void 0),s(O(r),"_height",void 0),s(O(r),"_buffer",void 0),s(O(r),"passes",1),r._width=t,r._height=o,r._buffer=new a.WebGLRenderTarget(t,o),r}return r(i,[{key:"setSize",value:function(t,e){this._width=t,this._height=e,this._buffer.setSize(t,e)}},{key:"render",value:function(t,e,n){for(var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=0;r<this.passes;++r)T(P(i.prototype),"render",this).call(this,t,this._buffer,0===r?n:e,J(J({},o),{},{direction:F.HORIZONTAL,resolution:this._width})),T(P(i.prototype),"render",this).call(this,t,e,this._buffer,J(J({},o),{},{direction:F.VERTICAL,resolution:this._height}))}},{key:"dispose",value:function(){this._buffer.dispose(),T(P(i.prototype),"dispose",this).call(this)}}]),i}(K),nt=function(){function t(e,i){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n(this,t),s(this,"_blurEffect",void 0),s(this,"_blendEffect",void 0),s(this,"_blendBuffer",void 0),this._blurEffect=new it(e,i),this._blendEffect=new tt(j.BlendShader,{mixRatio:.5}),this._blendBuffer=new a.WebGLRenderTarget(e,i),this.updateUniforms(o)}return r(t,[{key:"passes",get:function(){return this._blurEffect.passes},set:function(t){this._blurEffect.passes=t}},{key:"setSize",value:function(t,e){this._blurEffect.setSize(t,e),this._blendBuffer.setSize(t,e)}},{key:"getUniforms",value:function(){var t=this._blendEffect.getUniforms().opacity;return J(J({},this._blurEffect.getUniforms()),{},{opacity:t})}},{key:"updateUniforms",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this._blendEffect.getUniforms(),n=t.opacity,o=void 0===n?e.opacity:n,r=i(t,Z);this._blurEffect.updateUniforms(r),this._blendEffect.updateUniforms({opacity:o})}},{key:"clearUniforms",value:function(){this._blurEffect.clearUniforms(),this._blendEffect.clearUniforms(),this._blendEffect.updateUniforms({mixRatio:.5})}},{key:"render",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this._blurEffect.render(t,this._blendBuffer,i,n),this._blendEffect.render(t,e,i,this._blendBuffer)}},{key:"dispose",value:function(){this._blendEffect.dispose(),this._blendBuffer.dispose()}}]),t}(),ot=function(t){E(i,t);var e=Q(i);function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(this,i),e.call(this,V.RGBShiftShader,t)}return r(i)}(K),rt=function(t){E(i,t);var e=Q(i);function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(this,i),e.call(this,L.VignetteShader,t)}return r(i)}(K),st=function(){function t(e,i){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n(this,t),s(this,"_blurEffect",void 0),s(this,"_blendEffect",void 0),s(this,"_blendBuffer",void 0),this._blurEffect=new it(e,i),this._blendEffect=new tt(W),this._blendBuffer=new a.WebGLRenderTarget(e,i),this.updateUniforms(o)}return r(t,[{key:"passes",get:function(){return this._blurEffect.passes},set:function(t){this._blurEffect.passes=t}},{key:"setSize",value:function(t,e){this._blurEffect.setSize(t,e),this._blendBuffer.setSize(t,e)}},{key:"getUniforms",value:function(){var t=this._blendEffect.getUniforms().size;return J(J({},this._blurEffect.getUniforms()),{},{size:t})}},{key:"updateUniforms",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this._blendEffect.getUniforms(),n=t.size,o=void 0===n?e.size:n,r=i(t,H);this._blurEffect.updateUniforms(r),this._blendEffect.updateUniforms({size:o})}},{key:"clearUniforms",value:function(){this._blurEffect.clearUniforms(),this._blendEffect.clearUniforms()}},{key:"render",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this._blurEffect.render(t,this._blendBuffer,i,n),this._blendEffect.render(t,e,i,this._blendBuffer)}},{key:"dispose",value:function(){this._blurEffect.dispose(),this._blendEffect.dispose(),this._blendBuffer.dispose()}}]),t}(),at=function(){function t(e,i){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n(this,t),s(this,"_resolution",void 0),s(this,"_glitchEffect",void 0),s(this,"_blurEffect",void 0),s(this,"_blurBuffer",void 0),this._resolution=new a.Vector2(e,i),this._glitchEffect=new tt(N),this._blurEffect=new it(e,i,{radius:3}),this._blurEffect.passes=2,this._blurBuffer=new a.WebGLRenderTarget(e,i),this.updateUniforms(o)}return r(t,[{key:"setSize",value:function(t,e){this._resolution.set(t,e),this._blurEffect.setSize(t,e),this._blurBuffer.setSize(t,e)}},{key:"getUniforms",value:function(){return this._glitchEffect.getUniforms()}},{key:"updateUniforms",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._glitchEffect.updateUniforms(t)}},{key:"clearUniforms",value:function(){this._glitchEffect.clearUniforms()}},{key:"render",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this._blurEffect.render(t,this._blurBuffer,i),this._glitchEffect.render(t,e,i,this._blurBuffer,J(J({},n),{},{resolution:this._resolution}))}},{key:"dispose",value:function(){this._glitchEffect.dispose(),this._blurEffect.dispose(),this._blurBuffer.dispose()}}]),t}();var ut=function(t){E(u,t);var e,i,o=(e=u,i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=P(e);if(i){var o=P(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return z(this,t)});function u(t,e){var i;return n(this,u),s(O(i=o.call(this)),"_width",void 0),s(O(i),"_height",void 0),s(O(i),"_readBuffer",void 0),s(O(i),"_writeBuffer",void 0),s(O(i),"_copyShader",new K(A.CopyShader)),s(O(i),"_effects",{}),i._width=t,i._height=e,i._readBuffer=new a.WebGLRenderTarget(t,e),i._writeBuffer=new a.WebGLRenderTarget(t,e),i.enabled=!1,i}return r(u,[{key:"setSize",value:function(t,e){this._width=t,this._height=e,this._readBuffer.setSize(t,e),this._writeBuffer.setSize(t,e);for(var i=0,n=Object.values(this._effects);i<n.length;i++){var o=n[i];o.setSize&&o.setSize(t,e)}}},{key:"getConfigs",value:function(){for(var t={},e=0,i=Object.entries(this._effects);e<i.length;e++){var n=(S=i[e],U=2,function(t){if(Array.isArray(t))return t}(S)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=i){var n,o,r=[],s=!0,a=!1;try{for(i=i.call(t);!(s=(n=i.next()).done)&&(r.push(n.value),!e||r.length!==e);s=!0);}catch(t){a=!0,o=t}finally{try{s||null==i.return||i.return()}finally{if(a)throw o}}return r}}(S,U)||function(t,e){if(t){if("string"==typeof t)return R(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);return"Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?R(t,e):void 0}}(S,U)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),o=n[0],r=n[1];switch(o){case X.Blur:var s=r.getUniforms().radius;t[o]={radius:s,passes:r.passes};break;case X.Bloom:var u=r.getUniforms(),f=u.opacity,c=u.radius;t[o]={opacity:f,radius:c,passes:r.passes};break;case X.RgbShift:var l=r.getUniforms(),h=l.amount,d=l.angle;t[o]={amount:h,angle:a.MathUtils.radToDeg(d)};break;case X.Vignette:var v=r.getUniforms(),p=v.offset,m=v.darkness;t[o]={offset:p,darkness:m};break;case X.VignetteBlur:var _=r.getUniforms(),g=_.size,y=_.radius;t[o]={size:g,radius:y,passes:r.passes};break;case X.Glitch:var b=r.getUniforms(),x=b.amount,w=b.seed;t[o]={amount:x,seed:w}}}var S,U;return t}},{key:"hasEffect",value:function(t){return this._effects.hasOwnProperty(t)}},{key:"hasEffects",value:function(){return 0!==Object.getOwnPropertyNames(this._effects).length}},{key:"_getEffect",value:function(t){if(!(t in this._effects))switch(t){case X.Blur:this._effects[t]=new it(this._width,this._height);break;case X.Bloom:this._effects[t]=new nt(this._width,this._height);break;case X.RgbShift:this._effects[t]=new ot;break;case X.Vignette:this._effects[t]=new rt;break;case X.VignetteBlur:this._effects[t]=new st(this._width,this._height);break;case X.Glitch:this._effects[t]=new at(this._width,this._height)}return this._effects[t]}},{key:"set",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=this._getEffect(t);switch(this.enabled=!0,t){case X.Blur:var n=e,o=n.radius,r=void 0===o?1:o,s=n.passes,u=void 0===s?i.passes:s;i.passes=u,i.updateUniforms({radius:r});break;case X.Bloom:var f=e,c=f.opacity,l=void 0===c?1:c,h=f.radius,d=void 0===h?1:h,v=f.passes,p=void 0===v?i.passes:v;i.passes=p,i.updateUniforms({opacity:l,radius:d});break;case X.RgbShift:var m=e,_=m.amount,g=void 0===_?.005:_,y=m.angle,b=void 0===y?0:y;i.updateUniforms({amount:g,angle:a.MathUtils.degToRad(b)});break;case X.Vignette:var x=e,w=x.offset,S=void 0===w?1:w,U=x.darkness,k=void 0===U?1:U;i.updateUniforms({offset:S,darkness:k});break;case X.VignetteBlur:var O=e,P=O.size,D=void 0===P?1:P,T=O.radius,M=void 0===T?1:T,E=O.passes,B=void 0===E?i.passes:E;i.passes=B,i.updateUniforms({radius:M,size:D});break;case X.Glitch:var z=e,R=z.amount,C=void 0===R?1:R,A=z.seed,j=void 0===A?Math.random():A;i.updateUniforms({amount:C,seed:j})}}},{key:"remove",value:function(t){return t in this._effects&&(this._effects[t].dispose(),delete this._effects[t],this.enabled=this.hasEffects(),!0)}},{key:"removeAll",value:function(){for(var t in this._effects)this._effects[t].dispose(),delete this._effects[t];this.enabled=!1}},{key:"_swapBuffers",value:function(){var t=this._readBuffer;this._readBuffer=this._writeBuffer,this._writeBuffer=t}},{key:"render",value:function(t,e,i){this._copyShader.render(t,this._readBuffer,i);for(var n=0,o=Object.values(this._effects);n<o.length;n++)o[n].render(t,this._writeBuffer,this._readBuffer),this._swapBuffers();this._copyShader.render(t,this.renderToScreen?null:e,this._readBuffer)}},{key:"dispose",value:function(){this._copyShader.dispose(),this._readBuffer.dispose(),this._readBuffer.texture.dispose(),this._writeBuffer.dispose(),this._writeBuffer.texture.dispose(),Object.values(this._effects).forEach((function(t){return t.dispose()}))}}]),u}(C.Pass);var ft=function(t){E(a,t);var e,i,o=(e=a,i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=P(e);if(i){var o=P(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return z(this,t)});function a(t,e,i,r){var u;return n(this,a),s(O(u=o.call(this,t,e)),"_camera",void 0),s(O(u),"_depthTexture",void 0),u._camera=i,u._depthTexture=r,u}return r(a,[{key:"getConfigs",value:function(){var t=T(P(a.prototype),"getConfigs",this).call(this),e=this._effects[X.MotionBlur];if(e){var i=e.getUniforms(),n=i.intensity,o=i.samples;t[X.MotionBlur]={intensity:n,samples:o}}return t}},{key:"_getEffect",value:function(t){return t!==X.MotionBlur||t in this._effects?T(P(a.prototype),"_getEffect",this).call(this,t):(this._effects[X.MotionBlur]=new et(this._camera,this._depthTexture),this._effects[X.MotionBlur])}},{key:"set",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t===X.MotionBlur){this.enabled=!0;var i=this._getEffect(X.MotionBlur),n=e,o=n.intensity,r=void 0===o?1:o,s=n.samples,u=void 0===s?32:s;i.updateUniforms({intensity:r,samples:u})}else T(P(a.prototype),"set",this).call(this,t,e)}}]),a}(ut),ct={uniforms:{},vertexShader:"\n\n    attribute float size;\n\n    // a value from 0 to 1 indicating the size of the blend gradient\n    attribute float gradient;\n    varying float v_gradient;\n\n    // a value from 0 to 1 indicating the opacity of the particle\n    attribute float opacity;\n    varying float v_opacity;\n\n    // the color of the particle\n    attribute vec3 color;\n    varying vec3 v_color;\n\n    void main() {\n      v_gradient = gradient;\n      v_opacity = opacity;\n      v_color = color;\n      \n      gl_PointSize = size;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    varying float v_diameter;\n    varying float v_gradient;\n    varying float v_opacity;\n    varying vec3 v_color;\n\n    void main() {\n      float radius = 0.5;\n      float distanceFromCenter = distance(gl_PointCoord, vec2(0.5, 0.5));\n      if (distanceFromCenter > radius) {\n        discard;\n      }\n      gl_FragColor = vec4(v_color, min((radius - distanceFromCenter) / smoothstep(0.0, 1.0, v_gradient * radius), 1.0) * v_opacity);\n    }\n\n  "};function lt(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var ht=function(){function t(e,i,o){n(this,t),s(this,"_width",void 0),s(this,"_height",void 0),s(this,"_maxDepth",void 0),s(this,"_groups",{}),s(this,"_particles",void 0),s(this,"_positions",[]),this._width=e,this._height=i,this._maxDepth=o;var r=new a.BufferGeometry;r.setAttribute("position",new a.Float32BufferAttribute(0,3)),r.setAttribute("size",new a.Float32BufferAttribute(0,1)),r.setAttribute("gradient",new a.Float32BufferAttribute(0,1)),r.setAttribute("opacity",new a.Float32BufferAttribute(0,1)),r.setAttribute("color",new a.Float32BufferAttribute(0,3)),this._particles=new a.Points(r,Y.createShaderMaterial(ct))}return r(t,[{key:"getConfigs",value:function(){for(var t={},e=0,i=Object.values(this._groups);e<i.length;e++){var n=i[e],o=n.name,r=n.amount,s=n.minSize,a=n.maxSize,u=n.minGradient,f=n.maxGradient,c=n.minOpacity,l=n.maxOpacity,h=n.color;t[o]={name:o,amount:r,minSize:s,maxSize:a,minGradient:u,maxGradient:f,minOpacity:c,maxOpacity:l,color:h}}return t}},{key:"isMoving",value:function(t){var e,i;return null!==(e=null===(i=this._groups[t])||void 0===i?void 0:i.positionTransition.isPlaying())&&void 0!==e&&e}},{key:"isSwaying",value:function(t){var e,i;return null!==(e=null===(i=this._groups[t])||void 0===i?void 0:i.swayTransition.isPlaying())&&void 0!==e&&e}},{key:"generate",value:function(t){this.removeAll();var e,i=0,n=function(t,e){var i="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!i){if(Array.isArray(t)||(i=function(t,e){if(t){if("string"==typeof t)return lt(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);return"Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?lt(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}(t=Array.isArray(t)?t:[t]);try{for(n.s();!(e=n.n()).done;){for(var o=e.value,r=o.name,s=o.amount,u=void 0===s?0:s,f=o.minSize,c=void 0===f?0:f,l=o.maxSize,h=void 0===l?0:l,d=o.minGradient,v=void 0===d?0:d,p=o.maxGradient,m=void 0===p?1:p,g=o.minOpacity,y=void 0===g?0:g,b=o.maxOpacity,x=void 0===b?1:b,w=o.color,S=void 0===w?16777215:w,U=o.smoothing,k=void 0===U?.5:U,O=0;O<u;++O){var P=-this._width/2+Math.random()*this._width,D=-this._height/2+Math.random()*this._height,T=this._maxDepth/4*Math.random();this._positions.push(P,D,T)}this._groups[r]={name:r,index:i,amount:u,minSize:c,maxSize:h,minGradient:v,maxGradient:m,minOpacity:y,maxOpacity:x,color:S,smoothing:k,swayOffset:new a.Vector2(0,0),positionTransition:new _({offsetX:0,offsetY:0}),swayTransition:new _({offsetX:0,offsetY:0})},i+=u}}catch(t){n.e(t)}finally{n.f()}var M=new a.BufferGeometry;M.setAttribute("position",new a.Float32BufferAttribute(3*i,3)),M.setAttribute("color",new a.Float32BufferAttribute(3*i,3)),M.setAttribute("size",new a.Float32BufferAttribute(i,1)),M.setAttribute("gradient",new a.Float32BufferAttribute(i,1)),M.setAttribute("opacity",new a.Float32BufferAttribute(i,1));var E=Y.createShaderMaterial(ct);E.transparent=!0,this._particles.geometry=M,this._particles.material=E}},{key:"removeAll",value:function(){for(var t in this._groups)this.sway(t,!1),this.move(t,!1);this._positions=[],this._groups={},this._particles.geometry.dispose(),this._particles.material.dispose()}},{key:"_getNewPosition",value:function(t,e){var i=e.x,n=e.y;i%=this._width,n%=this._height;var o=t.x+i,r=t.y+n,s=this._width/2,u=this._height/2;return Math.abs(t.x+i)>s&&(o=i>0?-s+(t.x+i-s)%this._width:s-(Math.abs(t.x+i)-s)%this._width),Math.abs(t.y+n)>u&&(r=n>0?-u+(t.y+n-u)%this._height:u-(Math.abs(t.y+n)-u)%this._height),new a.Vector2(o,r)}},{key:"_updatePositions",value:function(t,e,i,n){for(var o=t;o<t+e;++o){var r=this._getNewPosition(new a.Vector2(i[3*o],i[3*o+1]),n),s=r.x,u=r.y;this._positions[3*o]=s,this._positions[3*o+1]=u}}},{key:"move",value:function(t,e){var i=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=this._groups[t],r=o.index,s=o.amount;if("boolean"!=typeof e){o.positionTransition.stop();var u=n.loop,f=void 0!==u&&u,c=n.duration,h=void 0===c?0:c,d=n.easing,v=void 0===d?l.Linear.None:d,p=n.onStart,m=void 0===p?function(){return{}}:p,g=n.onUpdate,y=void 0===g?function(){return{}}:g,b=n.onComplete,x=void 0===b?function(){return{}}:b,w=n.onStop,S=void 0===w?function(){return{}}:w,U=e.distance,k=e.angle,O=U*Math.cos(a.MathUtils.degToRad(k)),P=U*Math.sin(a.MathUtils.degToRad(k));if(h>0){var D=this._positions.slice();o.positionTransition=new _({offsetX:0,offsetY:0}).to({offsetX:O,offsetY:P},1e3*h).easing(v).onStart(m).onUpdate((function(t){var e=t.offsetX,n=t.offsetY;i._updatePositions(r,s,D,new a.Vector2(e,n)),y()})).onComplete((function(){f&&i.move(t,e,n),x()})).onStop(S).start()}else this._updatePositions(r,s,this._positions,new a.Vector2(O,P))}else e||o.positionTransition.stop()}},{key:"sway",value:function(t,e){var i=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=this._groups[t],r=o.swayOffset;if("boolean"!=typeof e){o.swayTransition.stop();var s=n.loop,a=void 0!==s&&s,u=n.duration,f=void 0===u?0:u,c=n.easing,h=void 0===c?l.Linear.None:c,d=n.onStart,v=void 0===d?function(){return{}}:d,p=n.onUpdate,m=void 0===p?function(){return{}}:p,g=n.onComplete,y=void 0===g?function(){return{}}:g,b=n.onStop,x=void 0===b?function(){return{}}:b,w=e.x,S=e.y;o.swayTransition=new _({offsetX:r.x,offsetY:r.y}).to({offsetX:-w+Math.random()*w*2,offsetY:-S+Math.random()*S*2},1e3*f).easing(h).onStart(v).onUpdate((function(t){var e=t.offsetX,i=t.offsetY;r.set(e,i),m()})).onComplete((function(){a&&i.sway(t,e,n),y()})).onStop(x).start()}else e||o.swayTransition.stop()}},{key:"_generateNewRandomAveragedValue",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;n=Math.min(n,.95);var o=(i-e)/2,r=Math.max(Math.min(t+(-o+Math.random()*o*2),i),e),s=t*n+r*(1-n);return Math.max(Math.min(s,i),e)}},{key:"update",value:function(){for(var t=this._particles.geometry.attributes,e=t.position,i=t.size,n=t.gradient,o=t.opacity,r=t.color,s=0,u=Object.values(this._groups);s<u.length;s++)for(var f=u[s],c=f.index,l=f.amount,h=f.minSize,d=f.maxSize,v=f.minGradient,p=f.maxGradient,m=f.minOpacity,_=f.maxOpacity,g=f.color,y=f.smoothing,b=f.swayOffset,x=c;x<c+l;++x){var w=this._getNewPosition(new a.Vector2(this._positions[3*x],this._positions[3*x+1]),b),S=new a.Color(g);e.setXYZ(x,w.x,w.y,this._positions[3*x+2]),r.setXYZ(x,S.r,S.g,S.b),i.setX(x,this._generateNewRandomAveragedValue(i.getX(x),h,d,y)),n.setX(x,this._generateNewRandomAveragedValue(n.getX(x),v,p,y)),o.setX(x,this._generateNewRandomAveragedValue(o.getX(x),m,_,y))}t.position.needsUpdate=!0,t.size.needsUpdate=!0,t.gradient.needsUpdate=!0,t.opacity.needsUpdate=!0,t.color.needsUpdate=!0}},{key:"object",get:function(){return this._particles}},{key:"dispose",value:function(){this.removeAll(),this._particles.geometry.dispose(),this._particles.material.dispose()}}]),t}(),dt=function(){function t(e,i,o){n(this,t),s(this,"_buffer",void 0),s(this,"_plane",void 0),s(this,"_scene",void 0),s(this,"camera",void 0),s(this,"particles",void 0),s(this,"effects",void 0),this._buffer=new a.WebGLRenderTarget(i,o),this._buffer.depthTexture=new a.DepthTexture(i,o);var r=1/(e&&void 0!==e.image?e.image.width/e.image.height:1);this._plane=new a.Mesh(new a.PlaneGeometry(1,r),new a.MeshBasicMaterial({map:e})),this.camera=new k(this._plane,i,o),this.particles=new ht(1.1,1.1*r,S(this._plane,this.camera.camera,0)),this.effects=new ft(i,o,this.camera.camera,this._buffer.depthTexture),this._scene=new a.Scene,this._scene.add(this.particles.object),this._scene.add(this._plane)}return r(t,[{key:"texture",get:function(){return this._plane.material.map}},{key:"setSize",value:function(t,e){this.camera.setSize(t,e),this._buffer.setSize(t,e),this._buffer.depthTexture.image.width=t,this._buffer.depthTexture.image.height=e}},{key:"render",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this.camera.update(),this.particles.update(),t.setRenderTarget(this._buffer),t.render(this._scene,this.camera.camera),this.effects.hasEffects()?this.effects.render(t,e,this._buffer):(t.setRenderTarget(e),t.render(this._scene,this.camera.camera))}},{key:"dispose",value:function(){this._buffer.dispose(),this._buffer.texture.dispose(),this._buffer.depthTexture.dispose(),this._plane.geometry.dispose(),this._plane.material.dispose(),this.camera.dispose(),this.effects.dispose(),this.particles.dispose()}}]),t}();var vt,pt=function(t){E(a,t);var e,i,o=(e=a,i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=P(e);if(i){var o=P(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return z(this,t)});function a(t){var e;return n(this,a),s(O(e=o.call(this)),"_background",void 0),e._background=t,e}return r(a,[{key:"setBackground",value:function(t){this._background=t}},{key:"background",get:function(){return this._background}},{key:"setSize",value:function(t,e){this._background.setSize(t,e)}},{key:"render",value:function(t,e){this._background.render(t,this.renderToScreen?null:e)}},{key:"dispose",value:function(){this._background.dispose()}}]),a}(C.Pass);!function(t){t[t.Left=0]="Left",t[t.Right=1]="Right",t[t.Top=2]="Top",t[t.Bottom=3]="Bottom"}(vt||(vt={}));var mt,_t={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},amount:{value:0},gradient:{value:0},direction:{value:vt.Right},angle:{value:0},aspect:{value:1}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n    uniform float amount;\n    uniform float gradient;\n    uniform int direction;\n    uniform float angle;\n    uniform float aspect;\n    varying vec2 vUv;\n\n    void main() {\n      vec4 texel1 = texture2D(tDiffuse1, vUv);\n      vec4 texel2 = texture2D(tDiffuse2, vUv);\n\n      float position;\n      if (direction == 0) {\n        // WipeDirection.LEFT\n        position = 1.0 - vUv.x;\n      } else if (direction == 1) {\n        // WipeDirection.RIGHT\n        position = vUv.x;\n      } else if (direction == 2) {\n        // WipeDirection.TOP\n        position = vUv.y;\n      } else if (direction == 3) {\n        // WipeDirection.BOTTOM\n        position = 1.0 - vUv.y;\n      }\n\n      float rotationOffset;\n      float rotatedPosition;\n      if (direction < 2) {\n        // rotation for horizontal wipes\n        float slope = 1.0 / tan(angle);\n        rotationOffset = (1.0 / slope) / aspect;\n        rotatedPosition = (vUv.y / slope) / aspect;\n      } else {\n        // rotation for vertical wipes\n        float slope = tan(angle);\n        rotationOffset = slope / aspect;\n        rotatedPosition = (vUv.x * slope) / aspect;\n      }\n\n      // a tween that starts from one side of the texture and ends at the other side.\n      // this tween accounts for offsets due to the size of the blend gradient and angle of the wipe effect.\n      float wipeOffset = (-max(0.0, rotationOffset) - gradient) + ((1.0 + abs(rotationOffset) + gradient) * amount) + rotatedPosition;\n      if (position <= wipeOffset) {\n        gl_FragColor = texel2;\n      } else if (position <= wipeOffset + gradient) {\n        gl_FragColor = mix(texel2, texel1, (position - wipeOffset) / gradient);\n      } else {\n        gl_FragColor = texel1;\n      }\n    }\n\n  "};!function(t){t[t.Left=0]="Left",t[t.Right=1]="Right",t[t.Top=2]="Top",t[t.Bottom=3]="Bottom"}(mt||(mt={}));var gt,yt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},slides:{value:1},amount:{value:0},prevAmount:{value:0},intensity:{value:1},direction:{value:mt.Right},samples:{value:32}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    const int MAX_SAMPLES = 128;\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n    uniform int slides;\n    uniform float amount;\n    uniform float prevAmount;\n    uniform float intensity;\n    uniform int direction;\n    uniform int samples;\n    varying vec2 vUv;\n\n    float getComponentForDirection(int direction, vec2 uv) {\n      return direction < 2 ? uv.x : uv.y;\n    }\n\n    vec2 getVectorForDirection(int direction, vec2 uv, float position) {\n      return direction < 2 ? vec2(position, uv.y) : vec2(uv.x, position);\n    }\n\n    float getOffsetPosition(int direction, float uv, float offset) {\n      return direction == 1 || direction == 3\n        ? mod(uv + offset, 1.0)\n        : mod(uv + (1.0 - offset), 1.0);\n    }\n\n    void main() {\n      vec4 texel;\n      float offset = amount * float(slides);\n      float position = getComponentForDirection(direction, vUv);\n\n      bool isFirstSlide = direction == 1 || direction == 3\n        ? position + offset <= 1.0\n        : position - offset >= 0.0;\n\n      if (isFirstSlide) {\n        texel = texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));\n      } else {\n        texel = texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));\n      }\n\n      float velocity = (amount - prevAmount) * intensity;\n      for (int i = 1; i < MAX_SAMPLES; ++i) {\n        if (i >= samples) {\n          // hack to allow loop comparisons against uniforms\n          break;\n        }\n        float blurOffset = velocity * (float(i) / float(samples - 1) - 0.5);\n        bool isFirstSlide = direction == 1 || direction == 3\n          ? position + offset + blurOffset <= 1.0\n          : position - offset - blurOffset >= 0.0;\n        if (isFirstSlide) {\n          texel += texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));\n        } else {\n          texel += texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));\n        }\n      }\n\n      gl_FragColor = texel / max(1.0, float(samples));\n    }\n\n  "},bt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},amount:{value:0},prevAmount:{value:0},intensity:{value:1},samples:{value:32}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n\n  ",fragmentShader:"\n\n    const int MAX_SAMPLES = 128;\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n    uniform float amount;\n    uniform float prevAmount;\n    uniform float intensity;\n    uniform int samples;\n    varying vec2 vUv;\n\n\n    void main() {\n      vec4 texel = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), amount);\n      float velocity = (amount - prevAmount) * intensity;\n      for (int i = 1; i < MAX_SAMPLES; ++i) {\n        if (i >= samples) {\n          // hack to allow loop comparisons against uniforms\n          break;\n        }\n        float offset = velocity * (float(i) / float(samples - 1) - 0.5);\n        texel += mix(texture2D(tDiffuse1, vec2(vUv.x + offset, vUv.y)), texture2D(tDiffuse2, vec2(vUv.x + offset, vUv.y)), amount);\n      }\n\n      gl_FragColor = texel / max(1.0, float(samples));\n    }\n\n  "},xt=["easing","duration","delay","onInit","onStart","onUpdate","onComplete","onStop"];function wt(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function St(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?wt(Object(i),!0).forEach((function(e){s(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):wt(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}!function(t){t.None="None",t.Blend="Blend",t.Blur="Blur",t.Wipe="Wipe",t.Slide="Slide",t.Glitch="Glitch"}(gt||(gt={}));var Ut=function(t){E(f,t);var e,o,u=(e=f,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,i=P(e);if(o){var n=P(this).constructor;t=Reflect.construct(i,arguments,n)}else t=i.apply(this,arguments);return z(this,t)});function f(t,e,i){var o;return n(this,f),s(O(o=u.call(this)),"_width",void 0),s(O(o),"_height",void 0),s(O(o),"_prevBackground",void 0),s(O(o),"_buffer",void 0),s(O(o),"_transition",new _({amount:0})),s(O(o),"_transitionEffect",new tt(j.BlendShader,{mixRatio:1})),o._width=e,o._height=i,o._prevBackground=null!=t?t:new dt(null,e,i),o._buffer=new a.WebGLRenderTarget(e,i),o.enabled=!1,o}return r(f,[{key:"setSize",value:function(t,e){this._width=t,this._height=e,this._prevBackground.setSize(t,e),this._buffer.setSize(t,e)}},{key:"isTransitioning",value:function(){return this._transition.isPlaying()}},{key:"transition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=this._getTweenConfig(t,e,i),o=n.from,r=n.to,s=n.duration,a=n.delay,u=n.easing,f=n.onInit,c=n.onStart,l=n.onUpdate,h=n.onComplete,d=n.onStop;this._transition.stop(),f(),this._transition=new _(o).to(r,s).easing(u).onStart(c).onUpdate(l).onComplete(h).onStop(d).delay(a).start()}},{key:"_setTransitionEffect",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._transitionEffect.dispose(),this._transitionEffect=new tt(t,e)}},{key:"_getTweenConfig",value:function(t,e){var n=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=function(){n.enabled=!0},s=function(){n.enabled=!1,n._prevBackground.dispose(),n._prevBackground=t},u=o.easing,f=void 0===u?l.Linear.None:u,c=o.duration,h=void 0===c?0:c,d=o.delay,v=void 0===d?0:d,p=o.onInit,m=void 0===p?function(){return{}}:p,_=o.onStart,g=void 0===_?function(){return{}}:_,y=o.onUpdate,b=void 0===y?function(){return{}}:y,x=o.onComplete,w=void 0===x?function(){return{}}:x,S=o.onStop,U=void 0===S?function(){return{}}:S,k=i(o,xt),O={from:{amount:0},to:{amount:1},easing:f,duration:1e3*h,delay:1e3*v,onInit:function(){return m(n._prevBackground,t)},onStart:function(){g(n._prevBackground,t),r()},onUpdate:function(){return b(n._prevBackground,t)},onComplete:function(){w(n._prevBackground,t),s()},onStop:function(){U(n._prevBackground,t),s()}};switch(e){case gt.None:var P=O.onStart;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(j.BlendShader,{mixRatio:1}),P()}});case gt.Blend:var D=O.onStart,T=O.onUpdate;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(j.BlendShader),D()},onUpdate:function(t){var e=t.amount;n._transitionEffect.updateUniforms({mixRatio:e}),T()}});case gt.Wipe:var M=O.onStart,E=O.onUpdate,B=k,z=B.gradient,R=void 0===z?0:z,C=B.angle,A=void 0===C?0:C,F=B.direction,I=void 0===F?vt.Right:F;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(_t,{gradient:R,angle:a.MathUtils.degToRad(A),direction:I,aspect:n._width/n._height}),M()},onUpdate:function(t){var e=t.amount;n._transitionEffect.updateUniforms({amount:e,aspect:n._width/n._height}),E()}});case gt.Slide:var V=O.onStart,L=O.onUpdate,W=k,G=W.slides,q=void 0===G?1:G,X=W.intensity,Y=void 0===X?1:X,Z=W.samples,H=void 0===Z?32:Z,Q=W.direction,$=void 0===Q?mt.Right:Q;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(yt,{slides:q,intensity:Y,samples:H,direction:$}),V()},onUpdate:function(t){var e=t.amount,i=n._transitionEffect.getUniforms().amount;n._transitionEffect.updateUniforms({prevAmount:i,amount:e}),L()}});case gt.Blur:var J=O.onStart,K=O.onUpdate,tt=k,et=tt.intensity,it=void 0===et?1:et,nt=tt.samples,ot=void 0===nt?32:nt;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(bt,{intensity:it,samples:ot}),J()},onUpdate:function(t){var e=t.amount,i=n._transitionEffect.getUniforms().amount;n._transitionEffect.updateUniforms({prevAmount:i,amount:e}),K()}});case gt.Glitch:var rt=O.onStart,st=O.onUpdate,at=k,ut=at.seed,ft=void 0===ut?Math.random():ut;return St(St({},O),{},{onStart:function(){n._setTransitionEffect(N,{seed:ft,resolution:new a.Vector2(n._width,n._height)}),rt()},onUpdate:function(t){var e=t.amount;n._transitionEffect.getUniforms().resolution.set(n._width,n._height),n._transitionEffect.updateUniforms({amount:e}),st()}});default:return O}}},{key:"render",value:function(t,e,i){this.isTransitioning()&&(this._prevBackground.render(t,this._buffer),this._transitionEffect.render(t,this.renderToScreen?null:e,this._buffer,i))}},{key:"dispose",value:function(){this._transition.stop(),this._prevBackground.dispose(),this._buffer.dispose(),this._transitionEffect.dispose()}}]),f}(C.Pass),kt=["onStart"];function Ot(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function Pt(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?Ot(Object(i),!0).forEach((function(e){s(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):Ot(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function Dt(){return f.WEBGL.isWebGLAvailable()}function Tt(t){return new Promise((function(e,i){(new a.TextureLoader).load(t,(function(t){t.wrapS=a.ClampToEdgeWrapping,t.wrapT=a.ClampToEdgeWrapping,t.minFilter=a.LinearFilter,t.repeat.set(1,1),e(t)}),(function(){return{}}),(function(t){var e;return i(null!==(e=t.error)&&void 0!==e?e:new Error("Failed to load requested image. Verify CORS policy or check if the image is valid."))}))}))}var Mt=function(){function t(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(this,t),s(this,"_renderer",void 0),s(this,"_composer",void 0),s(this,"_background",void 0),s(this,"_backgroundPass",void 0),s(this,"_transitionPass",void 0),s(this,"_effectPass",void 0),s(this,"_clock",new a.Clock(!1)),s(this,"_renderAnimationFrame",void 0),s(this,"_paused",!0),s(this,"_disposed",!1);var o=e.clientWidth,r=e.clientHeight;this._renderer=new a.WebGLRenderer({canvas:e,powerPreference:"high-performance"}),this._renderer.setSize(o,r,!1),this._composer=new u.EffectComposer(this._renderer),this._background=new dt(null,o,r),this._backgroundPass=new pt(this._background),this._transitionPass=new Ut(this._background,o,r),this._effectPass=new ut(o,r),this._composer.addPass(this._backgroundPass),this._composer.addPass(this._transitionPass),this._composer.addPass(this._effectPass),this._render=this._render.bind(this);var f=i.autoRender,c=void 0===f||f;c&&this.render()}return r(t,[{key:"effects",get:function(){return this._effectPass}},{key:"background",get:function(){return this._background}},{key:"isTransitioning",value:function(){return this._transitionPass.isTransitioning()}},{key:"setBackground",value:function(t,e){var n=this,o=this._renderer.domElement,r=o.clientWidth,s=o.clientHeight;if(this._background=new dt(t,r,s),e){var a=e.type,u=e.config,f=u.onStart,c=void 0===f?function(){return{}}:f,l=i(u,kt);this._transitionPass.transition(this._background,a,Pt(Pt({},l),{},{onStart:function(t,e){n._backgroundPass.setBackground(e),c(t,e)}}))}else this._backgroundPass.setBackground(this._background),this._transitionPass.transition(this._background,gt.None)}},{key:"_resizeCanvas",value:function(){var t=this._renderer.domElement,e=t.width,i=t.height,n=t.clientWidth,o=t.clientHeight;e===n&&i===o||(this._renderer.setSize(n,o,!1),this._composer.setSize(n,o),this._backgroundPass.setSize(n,o),this._transitionPass.setSize(n,o),this._effectPass.setSize(n,o))}},{key:"render",value:function(){void 0!==this._renderAnimationFrame&&(cancelAnimationFrame(this._renderAnimationFrame),this._renderAnimationFrame=void 0),this._paused=!1,this._clock.start(),this._render()}},{key:"pause",value:function(){this._paused=!0,this._clock.stop(),void 0!==this._renderAnimationFrame&&(cancelAnimationFrame(this._renderAnimationFrame),this._renderAnimationFrame=void 0)}},{key:"isPaused",get:function(){return this._paused}},{key:"_render",value:function(){y(),this._resizeCanvas(),this._disposed||(this._composer.render(this._clock.getDelta()),this._renderAnimationFrame=requestAnimationFrame(this._render))}},{key:"dispose",value:function(){this._disposed=!0,this._renderer.dispose(),this._backgroundPass.dispose(),this._transitionPass.dispose(),this._effectPass.dispose(),this._clock.stop()}}]),t}(),Et=l;exports.midori=e})();
-//# sourceMappingURL=midori.cjs.map
\ No newline at end of file
+"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const f=require("three"),dt=require("three/examples/jsm/capabilities/WebGL.js"),pt=require("three/examples/jsm/postprocessing/EffectComposer.js"),F=require("three/examples/jsm/postprocessing/Pass.js"),A=require("three/examples/jsm/shaders/BlendShader.js"),_t=require("three/examples/jsm/shaders/RGBShiftShader.js"),vt=require("three/examples/jsm/shaders/VignetteShader.js"),mt=require("three/examples/jsm/shaders/CopyShader.js"),gt=require("three/examples/jsm/postprocessing/OutputPass.js");var M={Linear:{None:function(e){return e}},Quadratic:{In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},Cubic:{In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},Quartic:{In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},Quintic:{In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},Sinusoidal:{In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return .5*(1-Math.cos(Math.PI*e))}},Exponential:{In:function(e){return e===0?0:Math.pow(1024,e-1)},Out:function(e){return e===1?1:1-Math.pow(2,-10*e)},InOut:function(e){return e===0?0:e===1?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(-Math.pow(2,-10*(e-1))+2)}},Circular:{In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},Elastic:{In:function(e){return e===0?0:e===1?1:-Math.pow(2,10*(e-1))*Math.sin((e-1.1)*5*Math.PI)},Out:function(e){return e===0?0:e===1?1:Math.pow(2,-10*e)*Math.sin((e-.1)*5*Math.PI)+1},InOut:function(e){return e===0?0:e===1?1:(e*=2,e<1?-.5*Math.pow(2,10*(e-1))*Math.sin((e-1.1)*5*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin((e-1.1)*5*Math.PI)+1)}},Back:{In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?.5*(e*e*((t+1)*e-t)):.5*((e-=2)*e*((t+1)*e+t)+2)}},Bounce:{In:function(e){return 1-M.Bounce.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?M.Bounce.In(e*2)*.5:M.Bounce.Out(e*2-1)*.5+.5}}},C;typeof self>"u"&&typeof process<"u"&&process.hrtime?C=function(){var e=process.hrtime();return e[0]*1e3+e[1]/1e6}:typeof self<"u"&&self.performance!==void 0&&self.performance.now!==void 0?C=self.performance.now.bind(self.performance):Date.now!==void 0?C=Date.now:C=function(){return new Date().getTime()};var T=C,xt=(function(){function e(){this._tweens={},this._tweensAddedDuringUpdate={}}return e.prototype.getAll=function(){var t=this;return Object.keys(this._tweens).map(function(i){return t._tweens[i]})},e.prototype.removeAll=function(){this._tweens={}},e.prototype.add=function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},e.prototype.remove=function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},e.prototype.update=function(t,i){t===void 0&&(t=T()),i===void 0&&(i=!1);var s=Object.keys(this._tweens);if(s.length===0)return!1;for(;s.length>0;){this._tweensAddedDuringUpdate={};for(var o=0;o<s.length;o++){var n=this._tweens[s[o]],r=!i;n&&n.update(t,r)===!1&&!i&&delete this._tweens[s[o]]}s=Object.keys(this._tweensAddedDuringUpdate)}return!0},e})(),Z={Linear:function(e,t){var i=e.length-1,s=i*t,o=Math.floor(s),n=Z.Utils.Linear;return t<0?n(e[0],e[1],s):t>1?n(e[i],e[i-1],i-s):n(e[o],e[o+1>i?i:o+1],s-o)},Utils:{Linear:function(e,t,i){return(t-e)*i+e}}},Q=(function(){function e(){}return e.nextId=function(){return e._nextId++},e._nextId=0,e})(),$=new xt,S=(function(){function e(t,i){i===void 0&&(i=$),this._object=t,this._group=i,this._isPaused=!1,this._pauseStart=0,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._initialRepeat=0,this._repeat=0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,this._startTime=0,this._easingFunction=M.Linear.None,this._interpolationFunction=Z.Linear,this._chainedTweens=[],this._onStartCallbackFired=!1,this._id=Q.nextId(),this._isChainStopped=!1,this._goToEnd=!1}return e.prototype.getId=function(){return this._id},e.prototype.isPlaying=function(){return this._isPlaying},e.prototype.isPaused=function(){return this._isPaused},e.prototype.to=function(t,i){return this._valuesEnd=Object.create(t),i!==void 0&&(this._duration=i),this},e.prototype.duration=function(t){return this._duration=t,this},e.prototype.start=function(t){if(this._isPlaying)return this;if(this._group&&this._group.add(this),this._repeat=this._initialRepeat,this._reversed){this._reversed=!1;for(var i in this._valuesStartRepeat)this._swapEndStartRepeatValues(i),this._valuesStart[i]=this._valuesStartRepeat[i]}return this._isPlaying=!0,this._isPaused=!1,this._onStartCallbackFired=!1,this._isChainStopped=!1,this._startTime=t!==void 0?typeof t=="string"?T()+parseFloat(t):t:T(),this._startTime+=this._delayTime,this._setupProperties(this._object,this._valuesStart,this._valuesEnd,this._valuesStartRepeat),this},e.prototype._setupProperties=function(t,i,s,o){for(var n in s){var r=t[n],a=Array.isArray(r),c=a?"array":typeof r,u=!a&&Array.isArray(s[n]);if(!(c==="undefined"||c==="function")){if(u){var h=s[n];if(h.length===0)continue;h=h.map(this._handleRelativeValue.bind(this,r)),s[n]=[r].concat(h)}if((c==="object"||a)&&r&&!u){i[n]=a?[]:{};for(var m in r)i[n][m]=r[m];o[n]=a?[]:{},this._setupProperties(r,i[n],s[n],o[n])}else typeof i[n]>"u"&&(i[n]=r),a||(i[n]*=1),u?o[n]=s[n].slice().reverse():o[n]=i[n]||0}}},e.prototype.stop=function(){return this._isChainStopped||(this._isChainStopped=!0,this.stopChainedTweens()),this._isPlaying?(this._group&&this._group.remove(this),this._isPlaying=!1,this._isPaused=!1,this._onStopCallback&&this._onStopCallback(this._object),this):this},e.prototype.end=function(){return this._goToEnd=!0,this.update(1/0),this},e.prototype.pause=function(t){return t===void 0&&(t=T()),this._isPaused||!this._isPlaying?this:(this._isPaused=!0,this._pauseStart=t,this._group&&this._group.remove(this),this)},e.prototype.resume=function(t){return t===void 0&&(t=T()),!this._isPaused||!this._isPlaying?this:(this._isPaused=!1,this._startTime+=t-this._pauseStart,this._pauseStart=0,this._group&&this._group.add(this),this)},e.prototype.stopChainedTweens=function(){for(var t=0,i=this._chainedTweens.length;t<i;t++)this._chainedTweens[t].stop();return this},e.prototype.group=function(t){return this._group=t,this},e.prototype.delay=function(t){return this._delayTime=t,this},e.prototype.repeat=function(t){return this._initialRepeat=t,this._repeat=t,this},e.prototype.repeatDelay=function(t){return this._repeatDelayTime=t,this},e.prototype.yoyo=function(t){return this._yoyo=t,this},e.prototype.easing=function(t){return this._easingFunction=t,this},e.prototype.interpolation=function(t){return this._interpolationFunction=t,this},e.prototype.chain=function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];return this._chainedTweens=t,this},e.prototype.onStart=function(t){return this._onStartCallback=t,this},e.prototype.onUpdate=function(t){return this._onUpdateCallback=t,this},e.prototype.onRepeat=function(t){return this._onRepeatCallback=t,this},e.prototype.onComplete=function(t){return this._onCompleteCallback=t,this},e.prototype.onStop=function(t){return this._onStopCallback=t,this},e.prototype.update=function(t,i){if(t===void 0&&(t=T()),i===void 0&&(i=!0),this._isPaused)return!0;var s,o,n=this._startTime+this._duration;if(!this._goToEnd&&!this._isPlaying){if(t>n)return!1;i&&this.start(t)}if(this._goToEnd=!1,t<this._startTime)return!0;this._onStartCallbackFired===!1&&(this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),o=(t-this._startTime)/this._duration,o=this._duration===0||o>1?1:o;var r=this._easingFunction(o);if(this._updateProperties(this._object,this._valuesStart,this._valuesEnd,r),this._onUpdateCallback&&this._onUpdateCallback(this._object,o),o===1)if(this._repeat>0){isFinite(this._repeat)&&this._repeat--;for(s in this._valuesStartRepeat)!this._yoyo&&typeof this._valuesEnd[s]=="string"&&(this._valuesStartRepeat[s]=this._valuesStartRepeat[s]+parseFloat(this._valuesEnd[s])),this._yoyo&&this._swapEndStartRepeatValues(s),this._valuesStart[s]=this._valuesStartRepeat[s];return this._yoyo&&(this._reversed=!this._reversed),this._repeatDelayTime!==void 0?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,this._onRepeatCallback&&this._onRepeatCallback(this._object),!0}else{this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var a=0,c=this._chainedTweens.length;a<c;a++)this._chainedTweens[a].start(this._startTime+this._duration);return this._isPlaying=!1,!1}return!0},e.prototype._updateProperties=function(t,i,s,o){for(var n in s)if(i[n]!==void 0){var r=i[n]||0,a=s[n],c=Array.isArray(t[n]),u=Array.isArray(a),h=!c&&u;h?t[n]=this._interpolationFunction(a,o):typeof a=="object"&&a?this._updateProperties(t[n],r,a,o):(a=this._handleRelativeValue(r,a),typeof a=="number"&&(t[n]=r+(a-r)*o))}},e.prototype._handleRelativeValue=function(t,i){return typeof i!="string"?i:i.charAt(0)==="+"||i.charAt(0)==="-"?t+parseFloat(i):parseFloat(i)},e.prototype._swapEndStartRepeatValues=function(t){var i=this._valuesStartRepeat[t],s=this._valuesEnd[t];typeof s=="string"?this._valuesStartRepeat[t]=this._valuesStartRepeat[t]+parseFloat(s):this._valuesStartRepeat[t]=this._valuesEnd[t],this._valuesEnd[t]=i},e})();Q.nextId;var D=$;D.getAll.bind(D);D.removeAll.bind(D);D.add.bind(D);D.remove.bind(D);var bt=D.update.bind(D);function J(e,t){return 2*Math.tan(f.MathUtils.degToRad(t.fov)/2)*e}function yt(e,t){return J(e,t)*t.aspect}function K(e,t,i=0){const s=e>=t,o=s?e:t,n=s?t:e,r=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));if(n<=2*r*a*o||Math.abs(r-a)<1e-10){const u=.5*n;return{width:s?u/r:u/a,height:s?u/a:u/r}}const c=a*a-r*r;return{width:(e*a-t*r)/c,height:(t*a-e*r)/c}}function I(e,t,i){const{width:s,height:o}=e.geometry.parameters,{width:n,height:r}=K(s,o,i),a=2*Math.tan(f.MathUtils.degToRad(t.fov)/2),c=n/(a*t.aspect),u=r/a;return Math.min(c,u)+e.position.z}function wt(e,t,i,s){const o=I(e,t,s),n=i*o;return{width:yt(n,t),height:J(n,t)}}function St(e,t,i,s){const{width:o,height:n}=e.geometry.parameters,{width:r,height:a}=K(o,n,s),c=wt(e,t,i,s);return{width:r-c.width,height:a-c.height}}function Ut(e,t,i){const{x:s,y:o,z:n,w:r}=i,a=St(e,t,n,r),c=-(a.width/2)+s*a.width,u=a.height/2-o*a.height,h=I(e,t,r)*n;return new f.Vector4(c*Math.cos(r)-u*Math.sin(r),c*Math.sin(r)+u*Math.cos(r),h,r)}function P(e,t,i){return Math.max(Math.min(e,i),t)}const X=.9;class tt{constructor(t,i,s){this._position=new f.Vector4(0,0,1,0),this._positionOffset=new f.Vector4(0,0,0,0),this._positionWithOffset=this._position.clone(),this._positionTransition=new S({x:0,y:0,z:0}),this._rotationTransition=new S({zr:0}),this._swayOffset=new f.Vector4(0,0,0,0),this._swayTransition=new S({offsetX:0,offsetY:0,offsetZ:0,offsetZR:0}),this._plane=t,this.camera=new f.PerspectiveCamera(35,i/s,.001)}get position(){const{x:t,y:i,z:s,w:o}=this._position;return{x:t,y:i,z:s,zr:o}}get positionOffset(){const{x:t,y:i,z:s,w:o}=this._positionOffset;return{x:t,y:i,z:s,zr:o}}isMoving(){return this._positionTransition.isPlaying()}isRotating(){return this._rotationTransition.isPlaying()}isSwaying(){return this._swayTransition.isPlaying()}setSize(t,i){this.camera.aspect=t/i,this.camera.updateProjectionMatrix()}offset(t){const{x:i=0,y:s=0,z:o=0,zr:n=0}=t;this._positionOffset.set(i,s,o,n)}sway(t,i={}){if(typeof t=="boolean"){t||this._swayTransition.stop();return}this._swayTransition.stop();const{loop:s=!1,duration:o=0,delay:n=0,easing:r=M.Linear.None,onInit:a=()=>({}),onStart:c=()=>({}),onUpdate:u=()=>({}),onComplete:h=()=>({}),onStop:m=()=>({})}=i,{x:b=0,y=0,z:x=0,zr:p=0}=t,_=f.MathUtils.degToRad(p),v=P(this._position.x+this._positionOffset.x,0,1),g=Math.max(0,v-b),w=Math.min(1,v+b)-g,U=g+w*Math.random()-v,z=P(this._position.y+this._positionOffset.y,0,1),k=Math.max(0,z-y),nt=Math.min(1,z+y)-k,rt=k+nt*Math.random()-z,G=P(this._position.z+this._positionOffset.z,0,1),N=Math.max(0,G-x),at=Math.min(1,G+x)-N,ft=N+at*Math.random()-G;a(),this._swayTransition=new S({offsetX:this._swayOffset.x,offsetY:this._swayOffset.y,offsetZ:this._swayOffset.z,offsetZR:this._swayOffset.w}).to({offsetX:U,offsetY:rt,offsetZ:ft,offsetZR:-_+Math.random()*_*2},o*1e3).easing(r).onStart(c).onUpdate(({offsetX:ct,offsetY:ut,offsetZ:ht,offsetZR:lt})=>{this._swayOffset.set(ct,ut,ht,lt),u()}).onComplete(()=>{s&&this.sway(t,i),h()}).onStop(m).delay(n*1e3).start()}rotate(t,i={}){if(typeof t=="boolean"){t||this._rotationTransition.stop();return}this._rotationTransition.stop();const{duration:s=0,delay:o=0,easing:n=M.Linear.None,onInit:r=()=>({}),onStart:a=()=>({}),onUpdate:c=()=>({}),onComplete:u=()=>({}),onStop:h=()=>({})}=i,m=f.MathUtils.degToRad(t);r(),s>0||o>0?this._rotationTransition=new S({zr:this._position.w}).to({zr:m},s*1e3).easing(n).onStart(a).onUpdate(({zr:b})=>{this._position.set(this._position.x,this._position.y,this._position.z,b),c()}).onComplete(u).onStop(h).delay(o*1e3).start():this._position.set(this._position.x,this._position.y,this._position.z,m)}move(t,i={}){if(typeof t=="boolean"){t||this._positionTransition.stop();return}this._positionTransition.stop();const{x:s,y:o,z:n}=this._position,{x:r=s,y:a=o,z:c=n}=t,{duration:u=0,delay:h=0,easing:m=M.Linear.None,onInit:b=()=>({}),onStart:y=()=>({}),onUpdate:x=()=>({}),onComplete:p=()=>({}),onStop:_=()=>({})}=i;b(),u>0||h>0?this._positionTransition=new S({x:s,y:o,z:n}).to({x:r,y:a,z:c},u*1e3).easing(m).onStart(y).onUpdate(({x:v,y:g,z:l})=>{this._position.set(v,g,l,this._position.w),x()}).onComplete(p).onStop(_).delay(h*1e3).start():this._position.set(r,a,c,this._position.w)}update(){const t=this._positionWithOffset.z/I(this._plane,this.camera,this.camera.rotation.z);this._positionWithOffset.set(P(this._position.x+this._positionOffset.x+this._swayOffset.x*t,0,1),P(this._position.y+this._positionOffset.y+this._swayOffset.y*t,0,1),P((this._position.z+this._positionOffset.z+this._swayOffset.z)*X+(1-X),0,1),this._position.w+f.MathUtils.degToRad(this._positionOffset.w)+this._swayOffset.w);const{x:i,y:s,z:o}=Ut(this._plane,this.camera,this._positionWithOffset);this.camera.position.set(i,s,o),this.camera.rotation.z=this._position.w+f.MathUtils.degToRad(this._positionOffset.w)+this._swayOffset.w}dispose(){this.sway(!1),this.move(!1),this.rotate(!1)}}const Y=Object.freeze({HORIZONTAL:[1,0],VERTICAL:[0,1]}),Mt={uniforms:{tDiffuse:{value:null},radius:{value:1},resolution:{value:0},direction:{value:[0,0]}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    uniform sampler2D tDiffuse;
+    uniform float radius;
+    uniform float resolution;
+    uniform vec2 direction;
+    varying vec2 vUv;
+
+    void main() {
+      float blur = radius / resolution;
+      float h = direction.x;
+      float v = direction.y;
+
+      vec4 sum = vec4(0.0);
+
+      // optimized 33-tap filter that takes advantage of bilinear filtering (effectively 17 fetches)
+      sum += texture2D(tDiffuse, vec2(vUv.x - 15.0810810809 * blur * h, vUv.y - 15.0810810809 * blur * v)) * 1.13068382e-7;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 13.1351352551 * blur * h, vUv.y - 13.1351352551 * blur * v)) * 0.00000634313;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 11.1891891693 * blur * h, vUv.y - 11.1891891693 * blur * v)) * 0.00014981883;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 9.2432432422 * blur * h, vUv.y - 9.2432432422 * blur * v)) * 0.00181031093;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 7.29729729717 * blur * h, vUv.y - 7.29729729717 * blur * v)) * 0.01244177332;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 5.35135135135 * blur * h, vUv.y - 5.35135135135 * blur * v)) * 0.0518407222;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 3.40540540538 * blur * h, vUv.y - 3.40540540538 * blur * v)) * 0.13626704123;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 1.45945945945 * blur * h, vUv.y - 1.45945945945 * blur * v)) * 0.23145357738;
+
+      sum += texture2D(tDiffuse, vUv) * 0.13206059971;
+
+      sum += texture2D(tDiffuse, vec2(vUv.x + 1.45945945945 * blur * h, vUv.y + 1.45945945945 * blur * v)) * 0.23145357738;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 3.40540540538 * blur * h, vUv.y + 3.40540540538 * blur * v)) * 0.13626704123;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 5.35135135135 * blur * h, vUv.y + 5.35135135135 * blur * v)) * 0.0518407222;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 7.29729729717 * blur * h, vUv.y + 7.29729729717 * blur * v)) * 0.01244177332;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 9.2432432422 * blur * h, vUv.y + 9.2432432422 * blur * v)) * 0.00181031093;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 11.1891891693 * blur * h, vUv.y + 11.1891891693 * blur * v)) * 0.00014981883;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 13.1351352551 * blur * h, vUv.y + 13.1351352551 * blur * v)) * 0.00000634313;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 15.0810810809 * blur * h, vUv.y + 15.0810810809 * blur * v)) * 1.13068382e-7;
+
+      gl_FragColor = sum;
+    }
+  `},Dt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},size:{value:1}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float size;
+    varying vec2 vUv;
+
+    void main() {
+      vec2 uv = (vUv - vec2(0.5));
+      float mixRatio = smoothstep(0.0, 1.0, min(dot(uv, uv) * size, 1.0));
+      gl_FragColor = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), mixRatio);
+    }
+
+  `},Pt={uniforms:{tDiffuse:{value:null},tDepth:{value:null},clipToWorldMatrix:{value:new f.Matrix4},prevWorldToClipMatrix:{value:new f.Matrix4},intensity:{value:1},samples:{value:32}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse;
+    uniform sampler2D tDepth;
+    uniform mat4 clipToWorldMatrix;
+    uniform mat4 prevWorldToClipMatrix;
+    uniform float intensity;
+    uniform int samples;
+    varying vec2 vUv;
+
+    void main() {
+      float zOverW = texture2D(tDepth, vUv).x;
+      vec4 clipPosition = vec4(vUv.x, vUv.y, zOverW, 1.0);
+      vec4 worldPosition = clipToWorldMatrix * clipPosition;
+      worldPosition /= worldPosition.w;
+
+      vec4 prevClipPosition = prevWorldToClipMatrix * worldPosition;
+      prevClipPosition /= prevClipPosition.w;
+      vec2 velocity = ((clipPosition - prevClipPosition).xy + (clipPosition - prevClipPosition).zz) * intensity;
+
+      vec4 texel = texture2D(tDiffuse, vUv);
+      vec2 texelCoord = vUv;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        // this offset calculation centers the blur which avoids unevenness favoring the direction of the velocity
+        vec2 offset = velocity * (float(i) / float(samples - 1) - 0.5);
+        texel += texture2D(tDiffuse, vUv + offset);
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `},Tt=`
+
+//
+// Description : Array and textureless GLSL 2D simplex noise function.
+//      Author : Ian McEwan, Ashima Arts.
+//  Maintainer : stegu
+//     Lastmod : 20110822 (ijm)
+//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
+//               Distributed under the MIT License. See LICENSE file.
+//               https://github.com/ashima/webgl-noise
+//               https://github.com/stegu/webgl-noise
+// 
+
+vec3 mod289(vec3 x) {
+  return x - floor(x * (1.0 / 289.0)) * 289.0;
+}
+
+vec2 mod289(vec2 x) {
+  return x - floor(x * (1.0 / 289.0)) * 289.0;
+}
+
+vec3 permute(vec3 x) {
+  return mod289(((x*34.0)+1.0)*x);
+}
+
+float snoise(vec2 v) {
+  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
+                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
+                    -0.577350269189626,  // -1.0 + 2.0 * C.x
+                      0.024390243902439); // 1.0 / 41.0
+// First corner
+  vec2 i  = floor(v + dot(v, C.yy) );
+  vec2 x0 = v -   i + dot(i, C.xx);
+
+// Other corners
+  vec2 i1;
+  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
+  //i1.y = 1.0 - i1.x;
+  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
+  // x0 = x0 - 0.0 + 0.0 * C.xx ;
+  // x1 = x0 - i1 + 1.0 * C.xx ;
+  // x2 = x0 - 1.0 + 2.0 * C.xx ;
+  vec4 x12 = x0.xyxy + C.xxzz;
+  x12.xy -= i1;
+
+// Permutations
+  i = mod289(i); // Avoid truncation effects in permutation
+  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
+    + i.x + vec3(0.0, i1.x, 1.0 ));
+
+  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
+  m = m*m ;
+  m = m*m ;
+
+// Gradients: 41 points uniformly over a line, mapped onto a diamond.
+// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
+
+  vec3 x = 2.0 * fract(p * C.www) - 1.0;
+  vec3 h = abs(x) - 0.5;
+  vec3 ox = floor(x + 0.5);
+  vec3 a0 = x - ox;
+
+// Normalise gradients implicitly by scaling m
+// Approximation of: m *= inversesqrt( a0*a0 + h*h );
+  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
+
+// Compute final noise value at P
+  vec3 g;
+  g.x  = a0.x  * x0.x  + h.x  * x0.y;
+  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
+  return 130.0 * dot(m, g);
+}
+
+`,et={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},resolution:{value:null},amount:{value:0},seed:{value:1}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    ${Tt}
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float seed;
+    uniform vec2 resolution;
+    varying vec2 vUv;
+
+    vec2 tile(vec2 position, vec2 resolution, float size, float scale) {
+      vec2 tileSize = vec2(size / resolution.x * scale, size / resolution.y);
+      return tileSize * floor(position / tileSize);
+    }
+
+    float glitchNoise(vec2 position, vec2 resolution, float amount, float seed) {
+      // the amount affects the seeds used for noise and the multipliers for each type of glitch
+      float noise = 0.0;
+
+      // large rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 488.0, 15.0) * (1.0 + amount * seed * 8.0)) * amount - 0.5, 0.0);
+
+      // medium square glitch blocks
+      noise += max(snoise(tile(position, resolution, 100.0, 1.0) * (4.0 + amount * seed * 2.0)) * amount - 0.3, 0.0);
+
+      // medium rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 120.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);
+      noise += max(snoise(tile(position, resolution, 125.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);
+
+      // small rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 29.0, 16.0) * (4.0 + amount * seed * 2.0)) * amount - 0.2, 0.0);
+
+      // small square glitch blocks
+      noise += max(snoise(tile(position, resolution, 29.0, 1.0) * (8.0 + amount * seed * 2.0)) * amount - 0.7, 0.0);
+
+      if (noise >= 0.6) {
+        // thin glitch lines - fill existing glitch blocks
+        noise += max(snoise(tile(position, resolution, 1.1, 1000.0) * 1000.0) * amount, 0.0);
+      } else if (noise <= 0.0) {
+        // thin glitch lines - fill remaining empty space
+        float lineNoise = max(snoise(tile(position, resolution, 1.1, 500.0) * (500.0 + amount * seed * 100.0)) * amount, 0.0);
+        lineNoise += min(snoise(tile(position, resolution, 100.0, 3.0) * (4.0 + amount * seed * 2.0)) * amount, 0.0);
+        noise += max(lineNoise, 0.0);
+      }
+
+      // coerce to max glitch amount
+      float glitchCoerceThreshold = 0.9;
+      if (amount >= glitchCoerceThreshold) {
+        float percent = (amount - glitchCoerceThreshold) / (1.0 - glitchCoerceThreshold);
+        return noise + (1.0 * percent);
+      }
+
+      return noise;
+    }
+
+    vec4 rgbShift(sampler2D tex, vec2 position, vec3 offset) {
+      vec4 r = texture2D(tex, position + vec2(offset.r, 0.0));
+      vec4 g = texture2D(tex, position + vec2(offset.g, 0.0));
+      vec4 b = texture2D(tex, position + vec2(offset.b, 0.0));
+      return vec4(r.r, g.g, b.b, 1.0);
+    }
+
+    void main() {
+      float glitch = glitchNoise(vUv, resolution, amount, seed);
+
+      vec3 rgbShiftOffset = vec3(0.01, 0.0, -0.01);
+      vec4 texel1 = texture2D(tDiffuse1, vUv);
+      vec4 shiftedTexel1 = rgbShift(tDiffuse1, vUv, rgbShiftOffset);
+      vec4 texel2 = texture2D(tDiffuse2, vUv);
+      vec4 shiftedTexel2 = rgbShift(tDiffuse2, vUv, rgbShiftOffset);
+
+      vec4 color = texel1;
+      if (glitch >= 0.95) {
+        // no glitching
+        color = texel2;
+      } else if (glitch >= 0.7) {
+        // color-shifted new texture
+        color = shiftedTexel2;
+      } else if (glitch >= 0.6) {
+        // color-shifted original texture
+        color = shiftedTexel1;
+      } else if (glitch >= 0.5) {
+        // magenta glitch blocks
+        color = texel1 * vec4(1.2, 0.0, 1.2, 0.5);
+      } else if (glitch >= 0.4) {
+        // cyan glitch blocks
+        color = texel1 * vec4(0.0, 1.2, 1.2, 0.5);
+      } else if (glitch >= 0.38) {
+        // bright color-shifted new texture
+        color = shiftedTexel2 * 1.5;
+      } else if (glitch >= 0.2) {
+        // color-shifted original texture
+        color = shiftedTexel1;
+      }
+
+      gl_FragColor = color;
+    }
+
+  `};function Bt(e){const t={};for(const i in e.uniforms)t[i]=e.uniforms[i].value;return t}function it(e,t={}){for(const i in t){if(e.uniforms[i]===void 0)throw new Error(`Uniform "${i}" does not exist on shader "${e.name}"`);e.uniforms[i].value=t[i]}}function Et(e){e.uniforms=f.UniformsUtils.clone(e.uniforms)}function zt(e,t={}){const i=new f.ShaderMaterial({uniforms:f.UniformsUtils.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader});return it(i,t),i}const B={getUniforms:Bt,updateUniforms:it,clearUniforms:Et,createShaderMaterial:zt};var d=(e=>(e.Blur="Blur",e.Bloom="Bloom",e.RgbShift="RgbShift",e.Vignette="Vignette",e.VignetteBlur="VignetteBlur",e.MotionBlur="MotionBlur",e.Glitch="Glitch",e))(d||{});class E{constructor(t,i={}){this._quad=new F.FullScreenQuad,this._quad.material=B.createShaderMaterial(t,i)}getUniforms(){return B.getUniforms(this._quad.material)}updateUniforms(t={}){B.updateUniforms(this._quad.material,t)}clearUniforms(){B.clearUniforms(this._quad.material)}render(t,i,s,o={}){t.setRenderTarget(i),this.updateUniforms({...o,tDiffuse:s.texture}),this._quad.render(t)}dispose(){this._quad.material.dispose()}}class O extends E{render(t,i,s,o,n={}){t.setRenderTarget(i),this.updateUniforms({...n,tDiffuse1:s.texture,tDiffuse2:o.texture}),this._quad.render(t)}}class Ct extends E{constructor(t,i,s={}){super(Pt,s),this.camera=t,this.depthTexture=i}render(t,i,s,o={}){const{clipToWorldMatrix:n,prevWorldToClipMatrix:r}=this.getUniforms();super.render(t,i,s,{...o,tDepth:this.depthTexture,clipToWorldMatrix:n.copy(this.camera.projectionMatrixInverse).multiply(this.camera.matrixWorld)}),r.copy(this.camera.matrixWorldInverse).multiply(this.camera.projectionMatrix)}}class L extends E{constructor(t,i,s={}){super(Mt,s),this.passes=1,this._width=t,this._height=i,this._buffer=new f.WebGLRenderTarget(t,i)}setSize(t,i){this._width=t,this._height=i,this._buffer.setSize(t,i)}render(t,i,s,o={}){for(let n=0;n<this.passes;++n)super.render(t,this._buffer,n===0?s:i,{...o,direction:Y.HORIZONTAL,resolution:this._width}),super.render(t,i,this._buffer,{...o,direction:Y.VERTICAL,resolution:this._height})}dispose(){this._buffer.dispose(),super.dispose()}}class Ot{constructor(t,i,s={}){this._blurEffect=new L(t,i),this._blendEffect=new O(A.BlendShader,{mixRatio:.5}),this._blendBuffer=new f.WebGLRenderTarget(t,i),this.updateUniforms(s)}get passes(){return this._blurEffect.passes}set passes(t){this._blurEffect.passes=t}setSize(t,i){this._blurEffect.setSize(t,i),this._blendBuffer.setSize(t,i)}getUniforms(){const{opacity:t}=this._blendEffect.getUniforms();return{...this._blurEffect.getUniforms(),opacity:t}}updateUniforms(t={}){const i=this._blendEffect.getUniforms(),{opacity:s=i.opacity,...o}=t;this._blurEffect.updateUniforms(o),this._blendEffect.updateUniforms({opacity:s})}clearUniforms(){this._blurEffect.clearUniforms(),this._blendEffect.clearUniforms(),this._blendEffect.updateUniforms({mixRatio:.5})}render(t,i,s,o={}){this._blurEffect.render(t,this._blendBuffer,s,o),this._blendEffect.render(t,i,s,this._blendBuffer)}dispose(){this._blendEffect.dispose(),this._blendBuffer.dispose()}}class kt extends E{constructor(t={}){super(_t.RGBShiftShader,t)}}class At extends E{constructor(t={}){super(vt.VignetteShader,t)}}class Rt{constructor(t,i,s={}){this._blurEffect=new L(t,i),this._blendEffect=new O(Dt),this._blendBuffer=new f.WebGLRenderTarget(t,i),this.updateUniforms(s)}get passes(){return this._blurEffect.passes}set passes(t){this._blurEffect.passes=t}setSize(t,i){this._blurEffect.setSize(t,i),this._blendBuffer.setSize(t,i)}getUniforms(){const{size:t}=this._blendEffect.getUniforms();return{...this._blurEffect.getUniforms(),size:t}}updateUniforms(t={}){const i=this._blendEffect.getUniforms(),{size:s=i.size,...o}=t;this._blurEffect.updateUniforms(o),this._blendEffect.updateUniforms({size:s})}clearUniforms(){this._blurEffect.clearUniforms(),this._blendEffect.clearUniforms()}render(t,i,s,o={}){this._blurEffect.render(t,this._blendBuffer,s,o),this._blendEffect.render(t,i,s,this._blendBuffer)}dispose(){this._blurEffect.dispose(),this._blendEffect.dispose(),this._blendBuffer.dispose()}}class Ft{constructor(t,i,s={}){this._resolution=new f.Vector2(t,i),this._glitchEffect=new O(et),this._blurEffect=new L(t,i,{radius:3}),this._blurEffect.passes=2,this._blurBuffer=new f.WebGLRenderTarget(t,i),this.updateUniforms(s)}setSize(t,i){this._resolution.set(t,i),this._blurEffect.setSize(t,i),this._blurBuffer.setSize(t,i)}getUniforms(){return this._glitchEffect.getUniforms()}updateUniforms(t={}){this._glitchEffect.updateUniforms(t)}clearUniforms(){this._glitchEffect.clearUniforms()}render(t,i,s,o={}){this._blurEffect.render(t,this._blurBuffer,s),this._glitchEffect.render(t,i,s,this._blurBuffer,{...o,resolution:this._resolution})}dispose(){this._glitchEffect.dispose(),this._blurEffect.dispose(),this._blurBuffer.dispose()}}class W extends F.Pass{constructor(t,i){super(),this._copyShader=new E(mt.CopyShader),this._effects={},this._width=t,this._height=i,this._readBuffer=new f.WebGLRenderTarget(t,i),this._writeBuffer=new f.WebGLRenderTarget(t,i),this.enabled=!1}setSize(t,i){this._width=t,this._height=i,this._readBuffer.setSize(t,i),this._writeBuffer.setSize(t,i);for(const s of Object.values(this._effects))s.setSize&&s.setSize(t,i)}getConfigs(){const t={};for(const[i,s]of Object.entries(this._effects))switch(i){case d.Blur:{const{radius:o}=s.getUniforms();t[i]={radius:o,passes:s.passes};break}case d.Bloom:{const{opacity:o,radius:n}=s.getUniforms();t[i]={opacity:o,radius:n,passes:s.passes};break}case d.RgbShift:{const{amount:o,angle:n}=s.getUniforms();t[i]={amount:o,angle:f.MathUtils.radToDeg(n)};break}case d.Vignette:{const{offset:o,darkness:n}=s.getUniforms();t[i]={offset:o,darkness:n};break}case d.VignetteBlur:{const{size:o,radius:n}=s.getUniforms();t[i]={size:o,radius:n,passes:s.passes};break}case d.Glitch:{const{amount:o,seed:n}=s.getUniforms();t[i]={amount:o,seed:n};break}}return t}hasEffect(t){return this._effects.hasOwnProperty(t)}hasEffects(){return Object.getOwnPropertyNames(this._effects).length!==0}_getEffect(t){if(!(t in this._effects))switch(t){case d.Blur:this._effects[t]=new L(this._width,this._height);break;case d.Bloom:this._effects[t]=new Ot(this._width,this._height);break;case d.RgbShift:this._effects[t]=new kt;break;case d.Vignette:this._effects[t]=new At;break;case d.VignetteBlur:this._effects[t]=new Rt(this._width,this._height);break;case d.Glitch:this._effects[t]=new Ft(this._width,this._height);break}return this._effects[t]}set(t,i={}){const s=this._getEffect(t);switch(this.enabled=!0,t){case d.Blur:{const{radius:o=1,passes:n=s.passes}=i;s.passes=n,s.updateUniforms({radius:o});break}case d.Bloom:{const{opacity:o=1,radius:n=1,passes:r=s.passes}=i;s.passes=r,s.updateUniforms({opacity:o,radius:n});break}case d.RgbShift:{const{amount:o=.005,angle:n=0}=i;s.updateUniforms({amount:o,angle:f.MathUtils.degToRad(n)});break}case d.Vignette:{const{offset:o=1,darkness:n=1}=i;s.updateUniforms({offset:o,darkness:n});break}case d.VignetteBlur:{const{size:o=1,radius:n=1,passes:r=s.passes}=i;s.passes=r,s.updateUniforms({radius:n,size:o});break}case d.Glitch:{const{amount:o=1,seed:n=Math.random()}=i;s.updateUniforms({amount:o,seed:n});break}}}remove(t){return t in this._effects?(this._effects[t].dispose(),delete this._effects[t],this.enabled=this.hasEffects(),!0):!1}removeAll(){for(const t in this._effects)this._effects[t].dispose(),delete this._effects[t];this.enabled=!1}_swapBuffers(){const t=this._readBuffer;this._readBuffer=this._writeBuffer,this._writeBuffer=t}render(t,i,s){this._copyShader.render(t,this._readBuffer,s);for(const o of Object.values(this._effects))o.render(t,this._writeBuffer,this._readBuffer),this._swapBuffers();this._copyShader.render(t,this.renderToScreen?null:i,this._readBuffer)}dispose(){this._copyShader.dispose(),this._readBuffer.dispose(),this._readBuffer.texture.dispose(),this._writeBuffer.dispose(),this._writeBuffer.texture.dispose(),Object.values(this._effects).forEach(t=>t.dispose())}}class st extends W{constructor(t,i,s,o){super(t,i),this._camera=s,this._depthTexture=o}getConfigs(){const t=super.getConfigs(),i=this._effects[d.MotionBlur];if(i){const{intensity:s,samples:o}=i.getUniforms();t[d.MotionBlur]={intensity:s,samples:o}}return t}_getEffect(t){return t===d.MotionBlur&&!(t in this._effects)?(this._effects[d.MotionBlur]=new Ct(this._camera,this._depthTexture),this._effects[d.MotionBlur]):super._getEffect(t)}set(t,i={}){if(t===d.MotionBlur){this.enabled=!0;const s=this._getEffect(d.MotionBlur),{intensity:o=1,samples:n=32}=i;s.updateUniforms({intensity:o,samples:n})}else super.set(t,i)}}const H={uniforms:{},vertexShader:`
+
+    attribute float size;
+
+    // a value from 0 to 1 indicating the size of the blend gradient
+    attribute float gradient;
+    varying float v_gradient;
+
+    // a value from 0 to 1 indicating the opacity of the particle
+    attribute float opacity;
+    varying float v_opacity;
+
+    // the color of the particle
+    attribute vec3 color;
+    varying vec3 v_color;
+
+    void main() {
+      v_gradient = gradient;
+      v_opacity = opacity;
+      v_color = color;
+      
+      gl_PointSize = size;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    varying float v_diameter;
+    varying float v_gradient;
+    varying float v_opacity;
+    varying vec3 v_color;
+
+    void main() {
+      float radius = 0.5;
+      float distanceFromCenter = distance(gl_PointCoord, vec2(0.5, 0.5));
+      if (distanceFromCenter > radius) {
+        discard;
+      }
+      gl_FragColor = vec4(v_color, min((radius - distanceFromCenter) / smoothstep(0.0, 1.0, v_gradient * radius), 1.0) * v_opacity);
+    }
+
+  `};class ot{constructor(t,i,s){this._groups={},this._positions=[],this._width=t,this._height=i,this._maxDepth=s;const o=new f.BufferGeometry;o.setAttribute("position",new f.Float32BufferAttribute(0,3)),o.setAttribute("size",new f.Float32BufferAttribute(0,1)),o.setAttribute("gradient",new f.Float32BufferAttribute(0,1)),o.setAttribute("opacity",new f.Float32BufferAttribute(0,1)),o.setAttribute("color",new f.Float32BufferAttribute(0,3)),this._particles=new f.Points(o,B.createShaderMaterial(H))}getConfigs(){const t={};for(const i of Object.values(this._groups)){const{name:s,amount:o,minSize:n,maxSize:r,minGradient:a,maxGradient:c,minOpacity:u,maxOpacity:h,color:m}=i;t[s]={name:s,amount:o,minSize:n,maxSize:r,minGradient:a,maxGradient:c,minOpacity:u,maxOpacity:h,color:m}}return t}isMoving(t){return this._groups[t]?.positionTransition.isPlaying()??!1}isSwaying(t){return this._groups[t]?.swayTransition.isPlaying()??!1}generate(t){this.removeAll(),t=Array.isArray(t)?t:[t];let i=0;for(const n of t){const{name:r,amount:a=0,minSize:c=0,maxSize:u=0,minGradient:h=0,maxGradient:m=1,minOpacity:b=0,maxOpacity:y=1,color:x=16777215,smoothing:p=.5}=n;for(let _=0;_<a;++_){const v=-this._width/2+Math.random()*this._width,g=-this._height/2+Math.random()*this._height,l=this._maxDepth/4*Math.random();this._positions.push(v,g,l)}this._groups[r]={name:r,index:i,amount:a,minSize:c,maxSize:u,minGradient:h,maxGradient:m,minOpacity:b,maxOpacity:y,color:x,smoothing:p,swayOffset:new f.Vector2(0,0),positionTransition:new S({offsetX:0,offsetY:0}),swayTransition:new S({offsetX:0,offsetY:0})},i+=a}const s=new f.BufferGeometry;s.setAttribute("position",new f.Float32BufferAttribute(i*3,3)),s.setAttribute("color",new f.Float32BufferAttribute(i*3,3)),s.setAttribute("size",new f.Float32BufferAttribute(i,1)),s.setAttribute("gradient",new f.Float32BufferAttribute(i,1)),s.setAttribute("opacity",new f.Float32BufferAttribute(i,1));const o=B.createShaderMaterial(H);o.transparent=!0,this._particles.geometry=s,this._particles.material=o}removeAll(){for(const t in this._groups)this.sway(t,!1),this.move(t,!1);this._positions=[],this._groups={},this._particles.geometry.dispose(),this._particles.material.dispose()}_getNewPosition(t,i){let{x:s,y:o}=i;s%=this._width,o%=this._height;let n=t.x+s,r=t.y+o;const a=this._width/2,c=this._height/2;return Math.abs(t.x+s)>a&&(n=s>0?-a+(t.x+s-a)%this._width:a-(Math.abs(t.x+s)-a)%this._width),Math.abs(t.y+o)>c&&(r=o>0?-c+(t.y+o-c)%this._height:c-(Math.abs(t.y+o)-c)%this._height),new f.Vector2(n,r)}_updatePositions(t,i,s,o){for(let n=t;n<t+i;++n){const{x:r,y:a}=this._getNewPosition(new f.Vector2(s[n*3],s[n*3+1]),o);this._positions[n*3]=r,this._positions[n*3+1]=a}}move(t,i,s={}){const o=this._groups[t],{index:n,amount:r}=o;if(typeof i=="boolean"){i||o.positionTransition.stop();return}o.positionTransition.stop();const{loop:a=!1,duration:c=0,easing:u=M.Linear.None,onStart:h=()=>({}),onUpdate:m=()=>({}),onComplete:b=()=>({}),onStop:y=()=>({})}=s,{distance:x,angle:p}=i,_=x*Math.cos(f.MathUtils.degToRad(p)),v=x*Math.sin(f.MathUtils.degToRad(p));if(c>0){const g=this._positions.slice();o.positionTransition=new S({offsetX:0,offsetY:0}).to({offsetX:_,offsetY:v},c*1e3).easing(u).onStart(h).onUpdate(({offsetX:l,offsetY:w})=>{this._updatePositions(n,r,g,new f.Vector2(l,w)),m()}).onComplete(()=>{a&&this.move(t,i,s),b()}).onStop(y).start()}else this._updatePositions(n,r,this._positions,new f.Vector2(_,v))}sway(t,i,s={}){const o=this._groups[t],{swayOffset:n}=o;if(typeof i=="boolean"){i||o.swayTransition.stop();return}o.swayTransition.stop();const{loop:r=!1,duration:a=0,easing:c=M.Linear.None,onStart:u=()=>({}),onUpdate:h=()=>({}),onComplete:m=()=>({}),onStop:b=()=>({})}=s,{x:y,y:x}=i;o.swayTransition=new S({offsetX:n.x,offsetY:n.y}).to({offsetX:-y+Math.random()*y*2,offsetY:-x+Math.random()*x*2},a*1e3).easing(c).onStart(u).onUpdate(({offsetX:p,offsetY:_})=>{n.set(p,_),h()}).onComplete(()=>{r&&this.sway(t,i,s),m()}).onStop(b).start()}_generateNewRandomAveragedValue(t,i,s,o=.5){o=Math.min(o,.95);const n=(s-i)/2,r=Math.max(Math.min(t+(-n+Math.random()*n*2),s),i),a=t*o+r*(1-o);return Math.max(Math.min(a,s),i)}update(){const{attributes:t}=this._particles.geometry,{position:i,size:s,gradient:o,opacity:n,color:r}=t;for(const a of Object.values(this._groups)){const{index:c,amount:u,minSize:h,maxSize:m,minGradient:b,maxGradient:y,minOpacity:x,maxOpacity:p,color:_,smoothing:v,swayOffset:g}=a;for(let l=c;l<c+u;++l){const w=this._getNewPosition(new f.Vector2(this._positions[l*3],this._positions[l*3+1]),g),U=new f.Color(_);i.setXYZ(l,w.x,w.y,this._positions[l*3+2]),r.setXYZ(l,U.r,U.g,U.b),s.setX(l,this._generateNewRandomAveragedValue(s.getX(l),h,m,v)),o.setX(l,this._generateNewRandomAveragedValue(o.getX(l),b,y,v)),n.setX(l,this._generateNewRandomAveragedValue(n.getX(l),x,p,v))}}t.position.needsUpdate=!0,t.size.needsUpdate=!0,t.gradient.needsUpdate=!0,t.opacity.needsUpdate=!0,t.color.needsUpdate=!0}get object(){return this._particles}dispose(){this.removeAll(),this._particles.geometry.dispose(),this._particles.material.dispose()}}class R{constructor(t,i,s){this._buffer=new f.WebGLRenderTarget(i,s,{colorSpace:f.SRGBColorSpace}),this._buffer.depthTexture=new f.DepthTexture(i,s);const o=t&&t.image!==void 0?t.image.width/t.image.height:1,n=1,r=1/o;this._plane=new f.Mesh(new f.PlaneGeometry(n,r),new f.MeshBasicMaterial({map:t})),this.camera=new tt(this._plane,i,s),this.particles=new ot(n*1.1,r*1.1,I(this._plane,this.camera.camera,0)),this.effects=new st(i,s,this.camera.camera,this._buffer.depthTexture),this._scene=new f.Scene,this._scene.add(this.particles.object),this._scene.add(this._plane)}get texture(){return this._plane.material.map}setSize(t,i){this.camera.setSize(t,i),this._buffer.setSize(t,i),this._buffer.depthTexture.image.width=t,this._buffer.depthTexture.image.height=i}render(t,i=null){this.camera.update(),this.particles.update(),t.setRenderTarget(this._buffer),t.render(this._scene,this.camera.camera),this.effects.hasEffects()?this.effects.render(t,i,this._buffer):(t.setRenderTarget(i),t.render(this._scene,this.camera.camera))}dispose(){this._buffer.dispose(),this._buffer.texture.dispose(),this._buffer.depthTexture.dispose(),this._plane.geometry.dispose(),this._plane.material.dispose(),this.camera.dispose(),this.effects.dispose(),this.particles.dispose()}}class It extends F.Pass{constructor(t){super(),this._background=t}setBackground(t){this._background=t}get background(){return this._background}setSize(t,i){this._background.setSize(t,i)}render(t,i){this._background.render(t,this.renderToScreen?null:i)}dispose(){this._background.dispose()}}const Lt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},amount:{value:0},prevAmount:{value:0},intensity:{value:1},samples:{value:32}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float prevAmount;
+    uniform float intensity;
+    uniform int samples;
+    varying vec2 vUv;
+
+
+    void main() {
+      vec4 texel = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), amount);
+      float velocity = (amount - prevAmount) * intensity;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        float offset = velocity * (float(i) / float(samples - 1) - 0.5);
+        texel += mix(texture2D(tDiffuse1, vec2(vUv.x + offset, vUv.y)), texture2D(tDiffuse2, vec2(vUv.x + offset, vUv.y)), amount);
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `};var j=(e=>(e[e.Left=0]="Left",e[e.Right=1]="Right",e[e.Top=2]="Top",e[e.Bottom=3]="Bottom",e))(j||{});const Gt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},slides:{value:1},amount:{value:0},prevAmount:{value:0},intensity:{value:1},direction:{value:1},samples:{value:32}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform int slides;
+    uniform float amount;
+    uniform float prevAmount;
+    uniform float intensity;
+    uniform int direction;
+    uniform int samples;
+    varying vec2 vUv;
+
+    float getComponentForDirection(int direction, vec2 uv) {
+      return direction < 2 ? uv.x : uv.y;
+    }
+
+    vec2 getVectorForDirection(int direction, vec2 uv, float position) {
+      return direction < 2 ? vec2(position, uv.y) : vec2(uv.x, position);
+    }
+
+    float getOffsetPosition(int direction, float uv, float offset) {
+      return direction == 1 || direction == 3
+        ? mod(uv + offset, 1.0)
+        : mod(uv + (1.0 - offset), 1.0);
+    }
+
+    void main() {
+      vec4 texel;
+      float offset = amount * float(slides);
+      float position = getComponentForDirection(direction, vUv);
+
+      bool isFirstSlide = direction == 1 || direction == 3
+        ? position + offset <= 1.0
+        : position - offset >= 0.0;
+
+      if (isFirstSlide) {
+        texel = texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));
+      } else {
+        texel = texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));
+      }
+
+      float velocity = (amount - prevAmount) * intensity;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        float blurOffset = velocity * (float(i) / float(samples - 1) - 0.5);
+        bool isFirstSlide = direction == 1 || direction == 3
+          ? position + offset + blurOffset <= 1.0
+          : position - offset - blurOffset >= 0.0;
+        if (isFirstSlide) {
+          texel += texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));
+        } else {
+          texel += texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));
+        }
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `};var V=(e=>(e[e.Left=0]="Left",e[e.Right=1]="Right",e[e.Top=2]="Top",e[e.Bottom=3]="Bottom",e))(V||{});const Wt={uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},amount:{value:0},gradient:{value:0},direction:{value:1},angle:{value:0},aspect:{value:1}},vertexShader:`
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,fragmentShader:`
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float gradient;
+    uniform int direction;
+    uniform float angle;
+    uniform float aspect;
+    varying vec2 vUv;
+
+    void main() {
+      vec4 texel1 = texture2D(tDiffuse1, vUv);
+      vec4 texel2 = texture2D(tDiffuse2, vUv);
+
+      float position;
+      if (direction == 0) {
+        // WipeDirection.LEFT
+        position = 1.0 - vUv.x;
+      } else if (direction == 1) {
+        // WipeDirection.RIGHT
+        position = vUv.x;
+      } else if (direction == 2) {
+        // WipeDirection.TOP
+        position = vUv.y;
+      } else if (direction == 3) {
+        // WipeDirection.BOTTOM
+        position = 1.0 - vUv.y;
+      }
+
+      float rotationOffset;
+      float rotatedPosition;
+      if (direction < 2) {
+        // rotation for horizontal wipes
+        float slope = 1.0 / tan(angle);
+        rotationOffset = (1.0 / slope) / aspect;
+        rotatedPosition = (vUv.y / slope) / aspect;
+      } else {
+        // rotation for vertical wipes
+        float slope = tan(angle);
+        rotationOffset = slope / aspect;
+        rotatedPosition = (vUv.x * slope) / aspect;
+      }
+
+      // a tween that starts from one side of the texture and ends at the other side.
+      // this tween accounts for offsets due to the size of the blend gradient and angle of the wipe effect.
+      float wipeOffset = (-max(0.0, rotationOffset) - gradient) + ((1.0 + abs(rotationOffset) + gradient) * amount) + rotatedPosition;
+      if (position <= wipeOffset) {
+        gl_FragColor = texel2;
+      } else if (position <= wipeOffset + gradient) {
+        gl_FragColor = mix(texel2, texel1, (position - wipeOffset) / gradient);
+      } else {
+        gl_FragColor = texel1;
+      }
+    }
+
+  `};var q=(e=>(e.None="None",e.Blend="Blend",e.Blur="Blur",e.Wipe="Wipe",e.Slide="Slide",e.Glitch="Glitch",e))(q||{});class jt extends F.Pass{constructor(t,i,s){super(),this._transition=new S({amount:0}),this._transitionEffect=new O(A.BlendShader,{mixRatio:1}),this._width=i,this._height=s,this._prevBackground=t??new R(null,i,s),this._buffer=new f.WebGLRenderTarget(i,s),this.enabled=!1}setSize(t,i){this._width=t,this._height=i,this._prevBackground.setSize(t,i),this._buffer.setSize(t,i)}isTransitioning(){return this._transition.isPlaying()}transition(t,i,s={}){const{from:o,to:n,duration:r,delay:a,easing:c,onInit:u,onStart:h,onUpdate:m,onComplete:b,onStop:y}=this._getTweenConfig(t,i,s);this._transition.stop(),u(),this._transition=new S(o).to(n,r).easing(c).onStart(h).onUpdate(m).onComplete(b).onStop(y).delay(a).start()}_setTransitionEffect(t,i={}){this._transitionEffect.dispose(),this._transitionEffect=new O(t,i)}_getTweenConfig(t,i,s={}){const o=()=>{this.enabled=!0},n=()=>{this.enabled=!1,this._prevBackground.dispose(),this._prevBackground=t},{easing:r=M.Linear.None,duration:a=0,delay:c=0,onInit:u=()=>({}),onStart:h=()=>({}),onUpdate:m=()=>({}),onComplete:b=()=>({}),onStop:y=()=>({}),...x}=s,p={from:{amount:0},to:{amount:1},easing:r,duration:a*1e3,delay:c*1e3,onInit:()=>u(this._prevBackground,t),onStart:()=>{h(this._prevBackground,t),o()},onUpdate:()=>m(this._prevBackground,t),onComplete:()=>{b(this._prevBackground,t),n()},onStop:()=>{y(this._prevBackground,t),n()}};switch(i){case"None":{const{onStart:_}=p;return{...p,onStart:()=>{this._setTransitionEffect(A.BlendShader,{mixRatio:1}),_()}}}case"Blend":{const{onStart:_,onUpdate:v}=p;return{...p,onStart:()=>{this._setTransitionEffect(A.BlendShader),_()},onUpdate:({amount:g})=>{this._transitionEffect.updateUniforms({mixRatio:g}),v()}}}case"Wipe":{const{onStart:_,onUpdate:v}=p,{gradient:g=0,angle:l=0,direction:w=V.Right}=x;return{...p,onStart:()=>{this._setTransitionEffect(Wt,{gradient:g,angle:f.MathUtils.degToRad(l),direction:w,aspect:this._width/this._height}),_()},onUpdate:({amount:U})=>{this._transitionEffect.updateUniforms({amount:U,aspect:this._width/this._height}),v()}}}case"Slide":{const{onStart:_,onUpdate:v}=p,{slides:g=1,intensity:l=1,samples:w=32,direction:U=j.Right}=x;return{...p,onStart:()=>{this._setTransitionEffect(Gt,{slides:g,intensity:l,samples:w,direction:U}),_()},onUpdate:({amount:z})=>{const{amount:k}=this._transitionEffect.getUniforms();this._transitionEffect.updateUniforms({prevAmount:k,amount:z}),v()}}}case"Blur":{const{onStart:_,onUpdate:v}=p,{intensity:g=1,samples:l=32}=x;return{...p,onStart:()=>{this._setTransitionEffect(Lt,{intensity:g,samples:l}),_()},onUpdate:({amount:w})=>{const{amount:U}=this._transitionEffect.getUniforms();this._transitionEffect.updateUniforms({prevAmount:U,amount:w}),v()}}}case"Glitch":{const{onStart:_,onUpdate:v}=p,{seed:g=Math.random()}=x;return{...p,onStart:()=>{this._setTransitionEffect(et,{seed:g,resolution:new f.Vector2(this._width,this._height)}),_()},onUpdate:({amount:l})=>{const{resolution:w}=this._transitionEffect.getUniforms();w.set(this._width,this._height),this._transitionEffect.updateUniforms({amount:l}),v()}}}default:return p}}render(t,i,s){this.isTransitioning()&&(this._prevBackground.render(t,this._buffer),this._transitionEffect.render(t,this.renderToScreen?null:i,this._buffer,s))}dispose(){this._transition.stop(),this._prevBackground.dispose(),this._buffer.dispose(),this._transitionEffect.dispose()}}function Vt(){return dt.isWebGL2Available()}function qt(e){return new Promise((t,i)=>{new f.TextureLoader().load(e,s=>{s.wrapS=f.ClampToEdgeWrapping,s.wrapT=f.ClampToEdgeWrapping,s.minFilter=f.LinearFilter,s.repeat.set(1,1),s.colorSpace=f.SRGBColorSpace,t(s)},()=>({}),s=>i(s.error??new Error("Failed to load requested image. Verify CORS policy or check if the image is valid.")))})}class Nt{constructor(t,i={}){this._clock=new f.Clock(!1),this._paused=!0,this._disposed=!1;const{clientWidth:s,clientHeight:o}=t;this._renderer=new f.WebGLRenderer({canvas:t,powerPreference:"high-performance"}),this._renderer.setSize(s,o,!1),this._composer=new pt.EffectComposer(this._renderer),this._background=new R(null,s,o),this._backgroundPass=new It(this._background),this._transitionPass=new jt(this._background,s,o),this._effectPass=new W(s,o),this._composer.addPass(this._backgroundPass),this._composer.addPass(this._transitionPass),this._composer.addPass(this._effectPass),this._composer.addPass(new gt.OutputPass),this._render=this._render.bind(this);const{autoRender:n=!0}=i;n&&this.render()}get effects(){return this._effectPass}get background(){return this._background}isTransitioning(){return this._transitionPass.isTransitioning()}setBackground(t,i){const{clientWidth:s,clientHeight:o}=this._renderer.domElement;if(this._background=new R(t,s,o),i){const{type:n,config:{onStart:r=()=>({}),...a}}=i;this._transitionPass.transition(this._background,n,{...a,onStart:(c,u)=>{this._backgroundPass.setBackground(u),r(c,u)}})}else this._backgroundPass.setBackground(this._background),this._transitionPass.transition(this._background,q.None)}_resizeCanvas(){const{width:t,height:i,clientWidth:s,clientHeight:o}=this._renderer.domElement;(t!==s||i!==o)&&(this._renderer.setSize(s,o,!1),this._composer.setSize(s,o),this._backgroundPass.setSize(s,o),this._transitionPass.setSize(s,o),this._effectPass.setSize(s,o))}render(){this._renderAnimationFrame!==void 0&&(cancelAnimationFrame(this._renderAnimationFrame),this._renderAnimationFrame=void 0),this._paused=!1,this._clock.start(),this._render()}pause(){this._paused=!0,this._clock.stop(),this._renderAnimationFrame!==void 0&&(cancelAnimationFrame(this._renderAnimationFrame),this._renderAnimationFrame=void 0)}get isPaused(){return this._paused}_render(){bt(),this._resizeCanvas(),this._disposed||(this._composer.render(this._clock.getDelta()),this._renderAnimationFrame=requestAnimationFrame(this._render))}dispose(){this._disposed=!0,this._renderer.dispose(),this._backgroundPass.dispose(),this._transitionPass.dispose(),this._effectPass.dispose(),this._clock.stop()}}const Xt=M;exports.Background=R;exports.BackgroundCamera=tt;exports.BackgroundEffects=st;exports.BackgroundRenderer=Nt;exports.Easings=Xt;exports.EffectPass=W;exports.EffectType=d;exports.Particles=ot;exports.SlideDirection=j;exports.TransitionType=q;exports.WipeDirection=V;exports.isWebGLSupported=Vt;exports.loadImage=qt;
diff --git a/dist/midori.js b/dist/midori.js
deleted file mode 100644
index aab0f8308bf7793e552effa99ac7f247ebce5162..0000000000000000000000000000000000000000
diff --git a/dist/midori.mjs b/dist/midori.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..f1fc1a8c22551f7813981b5c1489152badc62dcb
--- /dev/null
+++ b/dist/midori.mjs
@@ -0,0 +1,2485 @@
+import { MathUtils as U, Vector4 as I, PerspectiveCamera as xt, Matrix4 as q, ShaderMaterial as bt, UniformsUtils as J, Vector2 as T, WebGLRenderTarget as z, BufferGeometry as Y, Float32BufferAttribute as M, Points as yt, Color as wt, SRGBColorSpace as K, DepthTexture as St, Mesh as Ut, PlaneGeometry as Dt, MeshBasicMaterial as Mt, Scene as Pt, Clock as Tt, WebGLRenderer as zt, TextureLoader as Et, ClampToEdgeWrapping as H, LinearFilter as Ct } from "three";
+import Bt from "three/examples/jsm/capabilities/WebGL.js";
+import { EffectComposer as Ot } from "three/examples/jsm/postprocessing/EffectComposer.js";
+import { FullScreenQuad as kt, Pass as X } from "three/examples/jsm/postprocessing/Pass.js";
+import { BlendShader as L } from "three/examples/jsm/shaders/BlendShader.js";
+import { RGBShiftShader as At } from "three/examples/jsm/shaders/RGBShiftShader.js";
+import { VignetteShader as Rt } from "three/examples/jsm/shaders/VignetteShader.js";
+import { CopyShader as Ft } from "three/examples/jsm/shaders/CopyShader.js";
+import { OutputPass as It } from "three/examples/jsm/postprocessing/OutputPass.js";
+var D = {
+  Linear: {
+    None: function(e) {
+      return e;
+    }
+  },
+  Quadratic: {
+    In: function(e) {
+      return e * e;
+    },
+    Out: function(e) {
+      return e * (2 - e);
+    },
+    InOut: function(e) {
+      return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
+    }
+  },
+  Cubic: {
+    In: function(e) {
+      return e * e * e;
+    },
+    Out: function(e) {
+      return --e * e * e + 1;
+    },
+    InOut: function(e) {
+      return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
+    }
+  },
+  Quartic: {
+    In: function(e) {
+      return e * e * e * e;
+    },
+    Out: function(e) {
+      return 1 - --e * e * e * e;
+    },
+    InOut: function(e) {
+      return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
+    }
+  },
+  Quintic: {
+    In: function(e) {
+      return e * e * e * e * e;
+    },
+    Out: function(e) {
+      return --e * e * e * e * e + 1;
+    },
+    InOut: function(e) {
+      return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
+    }
+  },
+  Sinusoidal: {
+    In: function(e) {
+      return 1 - Math.cos(e * Math.PI / 2);
+    },
+    Out: function(e) {
+      return Math.sin(e * Math.PI / 2);
+    },
+    InOut: function(e) {
+      return 0.5 * (1 - Math.cos(Math.PI * e));
+    }
+  },
+  Exponential: {
+    In: function(e) {
+      return e === 0 ? 0 : Math.pow(1024, e - 1);
+    },
+    Out: function(e) {
+      return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
+    },
+    InOut: function(e) {
+      return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
+    }
+  },
+  Circular: {
+    In: function(e) {
+      return 1 - Math.sqrt(1 - e * e);
+    },
+    Out: function(e) {
+      return Math.sqrt(1 - --e * e);
+    },
+    InOut: function(e) {
+      return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
+    }
+  },
+  Elastic: {
+    In: function(e) {
+      return e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI);
+    },
+    Out: function(e) {
+      return e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e - 0.1) * 5 * Math.PI) + 1;
+    },
+    InOut: function(e) {
+      return e === 0 ? 0 : e === 1 ? 1 : (e *= 2, e < 1 ? -0.5 * Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) + 1);
+    }
+  },
+  Back: {
+    In: function(e) {
+      var t = 1.70158;
+      return e * e * ((t + 1) * e - t);
+    },
+    Out: function(e) {
+      var t = 1.70158;
+      return --e * e * ((t + 1) * e + t) + 1;
+    },
+    InOut: function(e) {
+      var t = 2.5949095;
+      return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
+    }
+  },
+  Bounce: {
+    In: function(e) {
+      return 1 - D.Bounce.Out(1 - e);
+    },
+    Out: function(e) {
+      return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
+    },
+    InOut: function(e) {
+      return e < 0.5 ? D.Bounce.In(e * 2) * 0.5 : D.Bounce.Out(e * 2 - 1) * 0.5 + 0.5;
+    }
+  }
+}, A;
+typeof self > "u" && typeof process < "u" && process.hrtime ? A = function() {
+  var e = process.hrtime();
+  return e[0] * 1e3 + e[1] / 1e6;
+} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? A = self.performance.now.bind(self.performance) : Date.now !== void 0 ? A = Date.now : A = function() {
+  return (/* @__PURE__ */ new Date()).getTime();
+};
+var C = A, Lt = (
+  /** @class */
+  (function() {
+    function e() {
+      this._tweens = {}, this._tweensAddedDuringUpdate = {};
+    }
+    return e.prototype.getAll = function() {
+      var t = this;
+      return Object.keys(this._tweens).map(function(i) {
+        return t._tweens[i];
+      });
+    }, e.prototype.removeAll = function() {
+      this._tweens = {};
+    }, e.prototype.add = function(t) {
+      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
+    }, e.prototype.remove = function(t) {
+      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
+    }, e.prototype.update = function(t, i) {
+      t === void 0 && (t = C()), i === void 0 && (i = !1);
+      var s = Object.keys(this._tweens);
+      if (s.length === 0)
+        return !1;
+      for (; s.length > 0; ) {
+        this._tweensAddedDuringUpdate = {};
+        for (var o = 0; o < s.length; o++) {
+          var n = this._tweens[s[o]], r = !i;
+          n && n.update(t, r) === !1 && !i && delete this._tweens[s[o]];
+        }
+        s = Object.keys(this._tweensAddedDuringUpdate);
+      }
+      return !0;
+    }, e;
+  })()
+), tt = {
+  Linear: function(e, t) {
+    var i = e.length - 1, s = i * t, o = Math.floor(s), n = tt.Utils.Linear;
+    return t < 0 ? n(e[0], e[1], s) : t > 1 ? n(e[i], e[i - 1], i - s) : n(e[o], e[o + 1 > i ? i : o + 1], s - o);
+  },
+  Utils: {
+    Linear: function(e, t, i) {
+      return (t - e) * i + e;
+    }
+  }
+}, et = (
+  /** @class */
+  (function() {
+    function e() {
+    }
+    return e.nextId = function() {
+      return e._nextId++;
+    }, e._nextId = 0, e;
+  })()
+), it = new Lt(), w = (
+  /** @class */
+  (function() {
+    function e(t, i) {
+      i === void 0 && (i = it), this._object = t, this._group = i, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = D.Linear.None, this._interpolationFunction = tt.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = et.nextId(), this._isChainStopped = !1, this._goToEnd = !1;
+    }
+    return e.prototype.getId = function() {
+      return this._id;
+    }, e.prototype.isPlaying = function() {
+      return this._isPlaying;
+    }, e.prototype.isPaused = function() {
+      return this._isPaused;
+    }, e.prototype.to = function(t, i) {
+      return this._valuesEnd = Object.create(t), i !== void 0 && (this._duration = i), this;
+    }, e.prototype.duration = function(t) {
+      return this._duration = t, this;
+    }, e.prototype.start = function(t) {
+      if (this._isPlaying)
+        return this;
+      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
+        this._reversed = !1;
+        for (var i in this._valuesStartRepeat)
+          this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
+      }
+      return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == "string" ? C() + parseFloat(t) : t : C(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;
+    }, e.prototype._setupProperties = function(t, i, s, o) {
+      for (var n in s) {
+        var r = t[n], a = Array.isArray(r), f = a ? "array" : typeof r, h = !a && Array.isArray(s[n]);
+        if (!(f === "undefined" || f === "function")) {
+          if (h) {
+            var c = s[n];
+            if (c.length === 0)
+              continue;
+            c = c.map(this._handleRelativeValue.bind(this, r)), s[n] = [r].concat(c);
+          }
+          if ((f === "object" || a) && r && !h) {
+            i[n] = a ? [] : {};
+            for (var v in r)
+              i[n][v] = r[v];
+            o[n] = a ? [] : {}, this._setupProperties(r, i[n], s[n], o[n]);
+          } else
+            typeof i[n] > "u" && (i[n] = r), a || (i[n] *= 1), h ? o[n] = s[n].slice().reverse() : o[n] = i[n] || 0;
+        }
+      }
+    }, e.prototype.stop = function() {
+      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
+    }, e.prototype.end = function() {
+      return this._goToEnd = !0, this.update(1 / 0), this;
+    }, e.prototype.pause = function(t) {
+      return t === void 0 && (t = C()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
+    }, e.prototype.resume = function(t) {
+      return t === void 0 && (t = C()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
+    }, e.prototype.stopChainedTweens = function() {
+      for (var t = 0, i = this._chainedTweens.length; t < i; t++)
+        this._chainedTweens[t].stop();
+      return this;
+    }, e.prototype.group = function(t) {
+      return this._group = t, this;
+    }, e.prototype.delay = function(t) {
+      return this._delayTime = t, this;
+    }, e.prototype.repeat = function(t) {
+      return this._initialRepeat = t, this._repeat = t, this;
+    }, e.prototype.repeatDelay = function(t) {
+      return this._repeatDelayTime = t, this;
+    }, e.prototype.yoyo = function(t) {
+      return this._yoyo = t, this;
+    }, e.prototype.easing = function(t) {
+      return this._easingFunction = t, this;
+    }, e.prototype.interpolation = function(t) {
+      return this._interpolationFunction = t, this;
+    }, e.prototype.chain = function() {
+      for (var t = [], i = 0; i < arguments.length; i++)
+        t[i] = arguments[i];
+      return this._chainedTweens = t, this;
+    }, e.prototype.onStart = function(t) {
+      return this._onStartCallback = t, this;
+    }, e.prototype.onUpdate = function(t) {
+      return this._onUpdateCallback = t, this;
+    }, e.prototype.onRepeat = function(t) {
+      return this._onRepeatCallback = t, this;
+    }, e.prototype.onComplete = function(t) {
+      return this._onCompleteCallback = t, this;
+    }, e.prototype.onStop = function(t) {
+      return this._onStopCallback = t, this;
+    }, e.prototype.update = function(t, i) {
+      if (t === void 0 && (t = C()), i === void 0 && (i = !0), this._isPaused)
+        return !0;
+      var s, o, n = this._startTime + this._duration;
+      if (!this._goToEnd && !this._isPlaying) {
+        if (t > n)
+          return !1;
+        i && this.start(t);
+      }
+      if (this._goToEnd = !1, t < this._startTime)
+        return !0;
+      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), o = (t - this._startTime) / this._duration, o = this._duration === 0 || o > 1 ? 1 : o;
+      var r = this._easingFunction(o);
+      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, r), this._onUpdateCallback && this._onUpdateCallback(this._object, o), o === 1)
+        if (this._repeat > 0) {
+          isFinite(this._repeat) && this._repeat--;
+          for (s in this._valuesStartRepeat)
+            !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = // eslint-disable-next-line
+            // @ts-ignore FIXME?
+            this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
+          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
+        } else {
+          this._onCompleteCallback && this._onCompleteCallback(this._object);
+          for (var a = 0, f = this._chainedTweens.length; a < f; a++)
+            this._chainedTweens[a].start(this._startTime + this._duration);
+          return this._isPlaying = !1, !1;
+        }
+      return !0;
+    }, e.prototype._updateProperties = function(t, i, s, o) {
+      for (var n in s)
+        if (i[n] !== void 0) {
+          var r = i[n] || 0, a = s[n], f = Array.isArray(t[n]), h = Array.isArray(a), c = !f && h;
+          c ? t[n] = this._interpolationFunction(a, o) : typeof a == "object" && a ? this._updateProperties(t[n], r, a, o) : (a = this._handleRelativeValue(r, a), typeof a == "number" && (t[n] = r + (a - r) * o));
+        }
+    }, e.prototype._handleRelativeValue = function(t, i) {
+      return typeof i != "string" ? i : i.charAt(0) === "+" || i.charAt(0) === "-" ? t + parseFloat(i) : parseFloat(i);
+    }, e.prototype._swapEndStartRepeatValues = function(t) {
+      var i = this._valuesStartRepeat[t], s = this._valuesEnd[t];
+      typeof s == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(s) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = i;
+    }, e;
+  })()
+);
+et.nextId;
+var P = it;
+P.getAll.bind(P);
+P.removeAll.bind(P);
+P.add.bind(P);
+P.remove.bind(P);
+var Gt = P.update.bind(P);
+function st(e, t) {
+  return 2 * Math.tan(U.degToRad(t.fov) / 2) * e;
+}
+function Wt(e, t) {
+  return st(e, t) * t.aspect;
+}
+function ot(e, t, i = 0) {
+  const s = e >= t, o = s ? e : t, n = s ? t : e, r = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));
+  if (n <= 2 * r * a * o || Math.abs(r - a) < 1e-10) {
+    const h = 0.5 * n;
+    return {
+      width: s ? h / r : h / a,
+      height: s ? h / a : h / r
+    };
+  }
+  const f = a * a - r * r;
+  return {
+    width: (e * a - t * r) / f,
+    height: (t * a - e * r) / f
+  };
+}
+function G(e, t, i) {
+  const { width: s, height: o } = e.geometry.parameters, { width: n, height: r } = ot(s, o, i), a = 2 * Math.tan(U.degToRad(t.fov) / 2), f = n / (a * t.aspect), h = r / a;
+  return Math.min(f, h) + e.position.z;
+}
+function jt(e, t, i, s) {
+  const o = G(e, t, s), n = i * o;
+  return {
+    width: Wt(n, t),
+    height: st(n, t)
+  };
+}
+function Nt(e, t, i, s) {
+  const { width: o, height: n } = e.geometry.parameters, { width: r, height: a } = ot(o, n, s), f = jt(e, t, i, s);
+  return {
+    width: r - f.width,
+    height: a - f.height
+  };
+}
+function Xt(e, t, i) {
+  const { x: s, y: o, z: n, w: r } = i, a = Nt(e, t, n, r), f = -(a.width / 2) + s * a.width, h = a.height / 2 - o * a.height, c = G(e, t, r) * n;
+  return new I(
+    // Make sure to rotate the x/y positions to get the actual correct positions relative to the camera rotation.
+    f * Math.cos(r) - h * Math.sin(r),
+    f * Math.sin(r) + h * Math.cos(r),
+    c,
+    r
+  );
+}
+function E(e, t, i) {
+  return Math.max(Math.min(e, i), t);
+}
+const Z = 0.9;
+class Vt {
+  /**
+   * Constructs a BackgroundCamera using a Background's plane.
+   * @param {PlaneMesh} plane - a three.js plane mesh representing the background.
+   * @param {Number} width - the width of the camera.
+   * @param {Number} height - the height of the camera.
+   */
+  constructor(t, i, s) {
+    this._position = new I(0, 0, 1, 0), this._positionOffset = new I(0, 0, 0, 0), this._positionWithOffset = this._position.clone(), this._positionTransition = new w({ x: 0, y: 0, z: 0 }), this._rotationTransition = new w({ zr: 0 }), this._swayOffset = new I(0, 0, 0, 0), this._swayTransition = new w({ offsetX: 0, offsetY: 0, offsetZ: 0, offsetZR: 0 }), this._plane = t, this.camera = new xt(35, i / s, 1e-3);
+  }
+  /**
+   * Returns the current position of the camera.
+   * @returns CameraPositionWithRotation
+   */
+  get position() {
+    const { x: t, y: i, z: s, w: o } = this._position;
+    return { x: t, y: i, z: s, zr: o };
+  }
+  /**
+   * Returns the current position offset of the camera.
+   * @returns CameraPositionWithRotation
+   */
+  get positionOffset() {
+    const { x: t, y: i, z: s, w: o } = this._positionOffset;
+    return { x: t, y: i, z: s, zr: o };
+  }
+  /**
+   * Returns whether the camera is currently moving.
+   * @returns boolean
+   */
+  isMoving() {
+    return this._positionTransition.isPlaying();
+  }
+  /**
+   * Returns whether the camera is currently rotating.
+   * @returns boolean
+   */
+  isRotating() {
+    return this._rotationTransition.isPlaying();
+  }
+  /**
+   * Returns whether the camera is currently swaying.
+   * @returns boolean
+   */
+  isSwaying() {
+    return this._swayTransition.isPlaying();
+  }
+  /**
+   * Sets the size of the camera.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this.camera.aspect = t / i, this.camera.updateProjectionMatrix();
+  }
+  /**
+   * Offsets the camera position.
+   * @param {CameraPositionWithRotation} offset - the offset to apply.
+   */
+  offset(t) {
+    const { x: i = 0, y: s = 0, z: o = 0, zr: n = 0 } = t;
+    this._positionOffset.set(i, s, o, n);
+  }
+  /**
+   * Sways the camera around its position. Cancels any in-progress sways.
+   * @param {CameraOffset | boolean} offset - the offset to sway on each axis in relative units from 0 to 1.
+   * The rotation offset (zr) must be specified in units of degrees.
+   * The x/y offsets should be set based off a z of 1 and will be scaled down appropriately based on the camera's current z position.
+   * If a boolean is passed in instead then the sway will either continue or stop based on the value.
+   * @param {LoopableTransitionConfig} transition - optional configuration for a transition.
+   */
+  sway(t, i = {}) {
+    if (typeof t == "boolean") {
+      t || this._swayTransition.stop();
+      return;
+    }
+    this._swayTransition.stop();
+    const {
+      loop: s = !1,
+      duration: o = 0,
+      delay: n = 0,
+      easing: r = D.Linear.None,
+      onInit: a = () => ({}),
+      onStart: f = () => ({}),
+      onUpdate: h = () => ({}),
+      onComplete: c = () => ({}),
+      onStop: v = () => ({})
+    } = i, { x = 0, y: b = 0, z: g = 0, zr: l = 0 } = t, d = U.degToRad(l), _ = E(this._position.x + this._positionOffset.x, 0, 1), m = Math.max(0, _ - x), y = Math.min(1, _ + x) - m, S = m + y * Math.random() - _, k = E(this._position.y + this._positionOffset.y, 0, 1), F = Math.max(0, k - b), ut = Math.min(1, k + b) - F, lt = F + ut * Math.random() - k, j = E(this._position.z + this._positionOffset.z, 0, 1), V = Math.max(0, j - g), dt = Math.min(1, j + g) - V, pt = V + dt * Math.random() - j;
+    a(), this._swayTransition = new w({
+      offsetX: this._swayOffset.x,
+      offsetY: this._swayOffset.y,
+      offsetZ: this._swayOffset.z,
+      offsetZR: this._swayOffset.w
+    }).to({
+      offsetX: S,
+      offsetY: lt,
+      offsetZ: pt,
+      offsetZR: -d + Math.random() * d * 2
+    }, o * 1e3).easing(r).onStart(f).onUpdate(({ offsetX: _t, offsetY: vt, offsetZ: mt, offsetZR: gt }) => {
+      this._swayOffset.set(_t, vt, mt, gt), h();
+    }).onComplete(() => {
+      s && this.sway(t, i), c();
+    }).onStop(v).delay(n * 1e3).start();
+  }
+  /**
+   * Rotates the camera on its z-axis. Cancels any in-progress rotations.
+   * @param {number | boolean} angle - the angle to rotate in degrees.
+   * If a boolean is passed in instead then the rotation will either continue or stop based on the value.
+   * @param {TransitionConfig} transition - optional configuration for a transition.
+   */
+  rotate(t, i = {}) {
+    if (typeof t == "boolean") {
+      t || this._rotationTransition.stop();
+      return;
+    }
+    this._rotationTransition.stop();
+    const {
+      duration: s = 0,
+      delay: o = 0,
+      easing: n = D.Linear.None,
+      onInit: r = () => ({}),
+      onStart: a = () => ({}),
+      onUpdate: f = () => ({}),
+      onComplete: h = () => ({}),
+      onStop: c = () => ({})
+    } = i, v = U.degToRad(t);
+    r(), s > 0 || o > 0 ? this._rotationTransition = new w({ zr: this._position.w }).to({ zr: v }, s * 1e3).easing(n).onStart(a).onUpdate(({ zr: x }) => {
+      this._position.set(this._position.x, this._position.y, this._position.z, x), f();
+    }).onComplete(h).onStop(c).delay(o * 1e3).start() : this._position.set(this._position.x, this._position.y, this._position.z, v);
+  }
+  /**
+   * Moves the camera to a relative position on the background. Cancels any in-progress moves.
+   * @param {CameraPosition | boolean} position - the position to move towards on each axis in relative units from 0 to 1.
+   * If a boolean is passed in instead then the move will either continue or stop based on the value.
+   * @param {TransitionConfig} transition - optional configuration for a transition.
+   */
+  move(t, i = {}) {
+    if (typeof t == "boolean") {
+      t || this._positionTransition.stop();
+      return;
+    }
+    this._positionTransition.stop();
+    const { x: s, y: o, z: n } = this._position, { x: r = s, y: a = o, z: f = n } = t, {
+      duration: h = 0,
+      delay: c = 0,
+      easing: v = D.Linear.None,
+      onInit: x = () => ({}),
+      onStart: b = () => ({}),
+      onUpdate: g = () => ({}),
+      onComplete: l = () => ({}),
+      onStop: d = () => ({})
+    } = i;
+    x(), h > 0 || c > 0 ? this._positionTransition = new w({ x: s, y: o, z: n }).to({ x: r, y: a, z: f }, h * 1e3).easing(v).onStart(b).onUpdate(({ x: _, y: m, z: u }) => {
+      this._position.set(_, m, u, this._position.w), g();
+    }).onComplete(l).onStop(d).delay(c * 1e3).start() : this._position.set(r, a, f, this._position.w);
+  }
+  /**
+   * Updates the camera position. Should be called on every render frame.
+   */
+  update() {
+    const t = this._positionWithOffset.z / G(this._plane, this.camera, this.camera.rotation.z);
+    this._positionWithOffset.set(
+      E(this._position.x + this._positionOffset.x + this._swayOffset.x * t, 0, 1),
+      E(this._position.y + this._positionOffset.y + this._swayOffset.y * t, 0, 1),
+      E((this._position.z + this._positionOffset.z + this._swayOffset.z) * Z + (1 - Z), 0, 1),
+      this._position.w + U.degToRad(this._positionOffset.w) + this._swayOffset.w
+    );
+    const { x: i, y: s, z: o } = Xt(
+      this._plane,
+      this.camera,
+      this._positionWithOffset
+    );
+    this.camera.position.set(i, s, o), this.camera.rotation.z = this._position.w + U.degToRad(this._positionOffset.w) + this._swayOffset.w;
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this.sway(!1), this.move(!1), this.rotate(!1);
+  }
+}
+const Q = Object.freeze({
+  HORIZONTAL: [1, 0],
+  VERTICAL: [0, 1]
+}), qt = {
+  uniforms: {
+    tDiffuse: { value: null },
+    // the radius of the blur - determines the offset distance for each tap
+    radius: { value: 1 },
+    // the length of the direction to be blurred (i.e width or height of texture)
+    resolution: { value: 0 },
+    // the direction of the blur
+    direction: { value: [0, 0] }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    uniform sampler2D tDiffuse;
+    uniform float radius;
+    uniform float resolution;
+    uniform vec2 direction;
+    varying vec2 vUv;
+
+    void main() {
+      float blur = radius / resolution;
+      float h = direction.x;
+      float v = direction.y;
+
+      vec4 sum = vec4(0.0);
+
+      // optimized 33-tap filter that takes advantage of bilinear filtering (effectively 17 fetches)
+      sum += texture2D(tDiffuse, vec2(vUv.x - 15.0810810809 * blur * h, vUv.y - 15.0810810809 * blur * v)) * 1.13068382e-7;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 13.1351352551 * blur * h, vUv.y - 13.1351352551 * blur * v)) * 0.00000634313;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 11.1891891693 * blur * h, vUv.y - 11.1891891693 * blur * v)) * 0.00014981883;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 9.2432432422 * blur * h, vUv.y - 9.2432432422 * blur * v)) * 0.00181031093;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 7.29729729717 * blur * h, vUv.y - 7.29729729717 * blur * v)) * 0.01244177332;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 5.35135135135 * blur * h, vUv.y - 5.35135135135 * blur * v)) * 0.0518407222;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 3.40540540538 * blur * h, vUv.y - 3.40540540538 * blur * v)) * 0.13626704123;
+      sum += texture2D(tDiffuse, vec2(vUv.x - 1.45945945945 * blur * h, vUv.y - 1.45945945945 * blur * v)) * 0.23145357738;
+
+      sum += texture2D(tDiffuse, vUv) * 0.13206059971;
+
+      sum += texture2D(tDiffuse, vec2(vUv.x + 1.45945945945 * blur * h, vUv.y + 1.45945945945 * blur * v)) * 0.23145357738;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 3.40540540538 * blur * h, vUv.y + 3.40540540538 * blur * v)) * 0.13626704123;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 5.35135135135 * blur * h, vUv.y + 5.35135135135 * blur * v)) * 0.0518407222;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 7.29729729717 * blur * h, vUv.y + 7.29729729717 * blur * v)) * 0.01244177332;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 9.2432432422 * blur * h, vUv.y + 9.2432432422 * blur * v)) * 0.00181031093;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 11.1891891693 * blur * h, vUv.y + 11.1891891693 * blur * v)) * 0.00014981883;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 13.1351352551 * blur * h, vUv.y + 13.1351352551 * blur * v)) * 0.00000634313;
+      sum += texture2D(tDiffuse, vec2(vUv.x + 15.0810810809 * blur * h, vUv.y + 15.0810810809 * blur * v)) * 1.13068382e-7;
+
+      gl_FragColor = sum;
+    }
+  `
+}, Yt = {
+  uniforms: {
+    tDiffuse1: { value: null },
+    tDiffuse2: { value: null },
+    size: { value: 1 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float size;
+    varying vec2 vUv;
+
+    void main() {
+      vec2 uv = (vUv - vec2(0.5));
+      float mixRatio = smoothstep(0.0, 1.0, min(dot(uv, uv) * size, 1.0));
+      gl_FragColor = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), mixRatio);
+    }
+
+  `
+}, Ht = {
+  uniforms: {
+    tDiffuse: { value: null },
+    // a depth buffer of the frame to be blurred
+    tDepth: { value: null },
+    // the clip -> world matrix of the current frame - used to calculate the velocity of the blur
+    clipToWorldMatrix: { value: new q() },
+    // the world -> clip matrix of the previous frame - used to calculate the velocity of the blur
+    prevWorldToClipMatrix: { value: new q() },
+    // a positive value that affects the intensity of the blur
+    intensity: { value: 1 },
+    // the number of samples to use (up to 128) - higher samples result in better quality at the cost of performance
+    samples: { value: 32 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse;
+    uniform sampler2D tDepth;
+    uniform mat4 clipToWorldMatrix;
+    uniform mat4 prevWorldToClipMatrix;
+    uniform float intensity;
+    uniform int samples;
+    varying vec2 vUv;
+
+    void main() {
+      float zOverW = texture2D(tDepth, vUv).x;
+      vec4 clipPosition = vec4(vUv.x, vUv.y, zOverW, 1.0);
+      vec4 worldPosition = clipToWorldMatrix * clipPosition;
+      worldPosition /= worldPosition.w;
+
+      vec4 prevClipPosition = prevWorldToClipMatrix * worldPosition;
+      prevClipPosition /= prevClipPosition.w;
+      vec2 velocity = ((clipPosition - prevClipPosition).xy + (clipPosition - prevClipPosition).zz) * intensity;
+
+      vec4 texel = texture2D(tDiffuse, vUv);
+      vec2 texelCoord = vUv;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        // this offset calculation centers the blur which avoids unevenness favoring the direction of the velocity
+        vec2 offset = velocity * (float(i) / float(samples - 1) - 0.5);
+        texel += texture2D(tDiffuse, vUv + offset);
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `
+}, Zt = `
+
+//
+// Description : Array and textureless GLSL 2D simplex noise function.
+//      Author : Ian McEwan, Ashima Arts.
+//  Maintainer : stegu
+//     Lastmod : 20110822 (ijm)
+//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
+//               Distributed under the MIT License. See LICENSE file.
+//               https://github.com/ashima/webgl-noise
+//               https://github.com/stegu/webgl-noise
+// 
+
+vec3 mod289(vec3 x) {
+  return x - floor(x * (1.0 / 289.0)) * 289.0;
+}
+
+vec2 mod289(vec2 x) {
+  return x - floor(x * (1.0 / 289.0)) * 289.0;
+}
+
+vec3 permute(vec3 x) {
+  return mod289(((x*34.0)+1.0)*x);
+}
+
+float snoise(vec2 v) {
+  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
+                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
+                    -0.577350269189626,  // -1.0 + 2.0 * C.x
+                      0.024390243902439); // 1.0 / 41.0
+// First corner
+  vec2 i  = floor(v + dot(v, C.yy) );
+  vec2 x0 = v -   i + dot(i, C.xx);
+
+// Other corners
+  vec2 i1;
+  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
+  //i1.y = 1.0 - i1.x;
+  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
+  // x0 = x0 - 0.0 + 0.0 * C.xx ;
+  // x1 = x0 - i1 + 1.0 * C.xx ;
+  // x2 = x0 - 1.0 + 2.0 * C.xx ;
+  vec4 x12 = x0.xyxy + C.xxzz;
+  x12.xy -= i1;
+
+// Permutations
+  i = mod289(i); // Avoid truncation effects in permutation
+  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
+    + i.x + vec3(0.0, i1.x, 1.0 ));
+
+  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
+  m = m*m ;
+  m = m*m ;
+
+// Gradients: 41 points uniformly over a line, mapped onto a diamond.
+// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
+
+  vec3 x = 2.0 * fract(p * C.www) - 1.0;
+  vec3 h = abs(x) - 0.5;
+  vec3 ox = floor(x + 0.5);
+  vec3 a0 = x - ox;
+
+// Normalise gradients implicitly by scaling m
+// Approximation of: m *= inversesqrt( a0*a0 + h*h );
+  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
+
+// Compute final noise value at P
+  vec3 g;
+  g.x  = a0.x  * x0.x  + h.x  * x0.y;
+  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
+  return 130.0 * dot(m, g);
+}
+
+`, nt = {
+  uniforms: {
+    tDiffuse1: { value: null },
+    tDiffuse2: { value: null },
+    resolution: { value: null },
+    amount: { value: 0 },
+    seed: { value: 1 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    ${Zt}
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float seed;
+    uniform vec2 resolution;
+    varying vec2 vUv;
+
+    vec2 tile(vec2 position, vec2 resolution, float size, float scale) {
+      vec2 tileSize = vec2(size / resolution.x * scale, size / resolution.y);
+      return tileSize * floor(position / tileSize);
+    }
+
+    float glitchNoise(vec2 position, vec2 resolution, float amount, float seed) {
+      // the amount affects the seeds used for noise and the multipliers for each type of glitch
+      float noise = 0.0;
+
+      // large rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 488.0, 15.0) * (1.0 + amount * seed * 8.0)) * amount - 0.5, 0.0);
+
+      // medium square glitch blocks
+      noise += max(snoise(tile(position, resolution, 100.0, 1.0) * (4.0 + amount * seed * 2.0)) * amount - 0.3, 0.0);
+
+      // medium rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 120.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);
+      noise += max(snoise(tile(position, resolution, 125.0, 8.0) * (4.0 + amount * seed * 4.0)) * amount - 0.2, 0.0);
+
+      // small rectangular glitch blocks
+      noise += max(snoise(tile(position, resolution, 29.0, 16.0) * (4.0 + amount * seed * 2.0)) * amount - 0.2, 0.0);
+
+      // small square glitch blocks
+      noise += max(snoise(tile(position, resolution, 29.0, 1.0) * (8.0 + amount * seed * 2.0)) * amount - 0.7, 0.0);
+
+      if (noise >= 0.6) {
+        // thin glitch lines - fill existing glitch blocks
+        noise += max(snoise(tile(position, resolution, 1.1, 1000.0) * 1000.0) * amount, 0.0);
+      } else if (noise <= 0.0) {
+        // thin glitch lines - fill remaining empty space
+        float lineNoise = max(snoise(tile(position, resolution, 1.1, 500.0) * (500.0 + amount * seed * 100.0)) * amount, 0.0);
+        lineNoise += min(snoise(tile(position, resolution, 100.0, 3.0) * (4.0 + amount * seed * 2.0)) * amount, 0.0);
+        noise += max(lineNoise, 0.0);
+      }
+
+      // coerce to max glitch amount
+      float glitchCoerceThreshold = 0.9;
+      if (amount >= glitchCoerceThreshold) {
+        float percent = (amount - glitchCoerceThreshold) / (1.0 - glitchCoerceThreshold);
+        return noise + (1.0 * percent);
+      }
+
+      return noise;
+    }
+
+    vec4 rgbShift(sampler2D tex, vec2 position, vec3 offset) {
+      vec4 r = texture2D(tex, position + vec2(offset.r, 0.0));
+      vec4 g = texture2D(tex, position + vec2(offset.g, 0.0));
+      vec4 b = texture2D(tex, position + vec2(offset.b, 0.0));
+      return vec4(r.r, g.g, b.b, 1.0);
+    }
+
+    void main() {
+      float glitch = glitchNoise(vUv, resolution, amount, seed);
+
+      vec3 rgbShiftOffset = vec3(0.01, 0.0, -0.01);
+      vec4 texel1 = texture2D(tDiffuse1, vUv);
+      vec4 shiftedTexel1 = rgbShift(tDiffuse1, vUv, rgbShiftOffset);
+      vec4 texel2 = texture2D(tDiffuse2, vUv);
+      vec4 shiftedTexel2 = rgbShift(tDiffuse2, vUv, rgbShiftOffset);
+
+      vec4 color = texel1;
+      if (glitch >= 0.95) {
+        // no glitching
+        color = texel2;
+      } else if (glitch >= 0.7) {
+        // color-shifted new texture
+        color = shiftedTexel2;
+      } else if (glitch >= 0.6) {
+        // color-shifted original texture
+        color = shiftedTexel1;
+      } else if (glitch >= 0.5) {
+        // magenta glitch blocks
+        color = texel1 * vec4(1.2, 0.0, 1.2, 0.5);
+      } else if (glitch >= 0.4) {
+        // cyan glitch blocks
+        color = texel1 * vec4(0.0, 1.2, 1.2, 0.5);
+      } else if (glitch >= 0.38) {
+        // bright color-shifted new texture
+        color = shiftedTexel2 * 1.5;
+      } else if (glitch >= 0.2) {
+        // color-shifted original texture
+        color = shiftedTexel1;
+      }
+
+      gl_FragColor = color;
+    }
+
+  `
+};
+function Qt(e) {
+  const t = {};
+  for (const i in e.uniforms)
+    t[i] = e.uniforms[i].value;
+  return t;
+}
+function rt(e, t = {}) {
+  for (const i in t) {
+    if (e.uniforms[i] === void 0)
+      throw new Error(`Uniform "${i}" does not exist on shader "${e.name}"`);
+    e.uniforms[i].value = t[i];
+  }
+}
+function $t(e) {
+  e.uniforms = J.clone(e.uniforms);
+}
+function Jt(e, t = {}) {
+  const i = new bt({
+    uniforms: J.clone(e.uniforms),
+    vertexShader: e.vertexShader,
+    fragmentShader: e.fragmentShader
+  });
+  return rt(i, t), i;
+}
+const B = {
+  getUniforms: Qt,
+  updateUniforms: rt,
+  clearUniforms: $t,
+  createShaderMaterial: Jt
+};
+var p = /* @__PURE__ */ ((e) => (e.Blur = "Blur", e.Bloom = "Bloom", e.RgbShift = "RgbShift", e.Vignette = "Vignette", e.VignetteBlur = "VignetteBlur", e.MotionBlur = "MotionBlur", e.Glitch = "Glitch", e))(p || {});
+class O {
+  /**
+   * Contructs an effect.
+   * @param {Shader} shader - a shader definition.
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i = {}) {
+    this._quad = new kt(), this._quad.material = B.createShaderMaterial(t, i);
+  }
+  /**
+   * Returns the current uniforms for the effect.
+   * @returns Uniforms
+   */
+  getUniforms() {
+    return B.getUniforms(this._quad.material);
+  }
+  /**
+   * Updates the specified uniforms for the effect.
+   * @param {Uniforms} uniforms
+   */
+  updateUniforms(t = {}) {
+    B.updateUniforms(this._quad.material, t);
+  }
+  /**
+   * Resets the uniforms for the effect back to its default values.
+   */
+  clearUniforms() {
+    B.clearUniforms(this._quad.material);
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniforms values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    t.setRenderTarget(i), this.updateUniforms({
+      ...o,
+      tDiffuse: s.texture
+    }), this._quad.render(t);
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._quad.material.dispose();
+  }
+}
+class R extends O {
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} fromBuffer - the buffer to transition from.
+   * @param {WebGLRenderTarget} toBuffer - the buffer to transition to.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o, n = {}) {
+    t.setRenderTarget(i), this.updateUniforms({
+      ...n,
+      tDiffuse1: s.texture,
+      tDiffuse2: o.texture
+    }), this._quad.render(t);
+  }
+}
+class Kt extends O {
+  /**
+   * Constructs a MotionBlurEffect.
+   * @param {PerspectiveCamera} camera - a three.js PerspectiveCamera.
+   * @param {DepthTexture} depthTexture - a three.js DepthTexture.
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i, s = {}) {
+    super(Ht, s), this.camera = t, this.depthTexture = i;
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    const { clipToWorldMatrix: n, prevWorldToClipMatrix: r } = this.getUniforms();
+    super.render(t, i, s, {
+      ...o,
+      tDepth: this.depthTexture,
+      clipToWorldMatrix: n.copy(this.camera.projectionMatrixInverse).multiply(this.camera.matrixWorld)
+    }), r.copy(this.camera.matrixWorldInverse).multiply(this.camera.projectionMatrix);
+  }
+}
+class W extends O {
+  /**
+   * Constructs a GaussianBlurEffect.
+   * @param {number} width
+   * @param {number} height
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i, s = {}) {
+    super(qt, s), this.passes = 1, this._width = t, this._height = i, this._buffer = new z(t, i);
+  }
+  /**
+   * Sets the size of the effect.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._width = t, this._height = i, this._buffer.setSize(t, i);
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget} writeBuffer - the buffer to render to.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    for (let n = 0; n < this.passes; ++n)
+      super.render(t, this._buffer, n === 0 ? s : i, {
+        ...o,
+        direction: Q.HORIZONTAL,
+        resolution: this._width
+      }), super.render(t, i, this._buffer, {
+        ...o,
+        direction: Q.VERTICAL,
+        resolution: this._height
+      });
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._buffer.dispose(), super.dispose();
+  }
+}
+class te {
+  /**
+   * Constructs a BloomEffect.
+   * @param {number} width
+   * @param {number} height
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i, s = {}) {
+    this._blurEffect = new W(t, i), this._blendEffect = new R(L, { mixRatio: 0.5 }), this._blendBuffer = new z(t, i), this.updateUniforms(s);
+  }
+  /**
+   * The number of blur passes to perform. More passes are expensive but result in stronger blurs and less artifacts.
+   * @returns number
+   */
+  get passes() {
+    return this._blurEffect.passes;
+  }
+  /**
+   * @param {number} value
+   */
+  set passes(t) {
+    this._blurEffect.passes = t;
+  }
+  /**
+   * Sets the size of the effect.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._blurEffect.setSize(t, i), this._blendBuffer.setSize(t, i);
+  }
+  /**
+   * Returns the current uniforms for the effect.
+   * @returns Uniforms
+   */
+  getUniforms() {
+    const { opacity: t } = this._blendEffect.getUniforms();
+    return { ...this._blurEffect.getUniforms(), opacity: t };
+  }
+  /**
+   * Updates the specified uniforms for the effect.
+   * @param {Uniforms} uniforms
+   */
+  updateUniforms(t = {}) {
+    const i = this._blendEffect.getUniforms(), { opacity: s = i.opacity, ...o } = t;
+    this._blurEffect.updateUniforms(o), this._blendEffect.updateUniforms({ opacity: s });
+  }
+  /**
+   * Resets the uniforms for the effect back to its default values.
+   */
+  clearUniforms() {
+    this._blurEffect.clearUniforms(), this._blendEffect.clearUniforms(), this._blendEffect.updateUniforms({ mixRatio: 0.5 });
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    this._blurEffect.render(t, this._blendBuffer, s, o), this._blendEffect.render(t, i, s, this._blendBuffer);
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._blendEffect.dispose(), this._blendBuffer.dispose();
+  }
+}
+class ee extends O {
+  /**
+   * Contructs a VignetteEffect.
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t = {}) {
+    super(At, t);
+  }
+}
+class ie extends O {
+  /**
+   * Contructs a VignetteEffect.
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t = {}) {
+    super(Rt, t);
+  }
+}
+class se {
+  /**
+   * Constructs a VignetteBlurEffect.
+   * @param {number} width
+   * @param {number} height
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i, s = {}) {
+    this._blurEffect = new W(t, i), this._blendEffect = new R(Yt), this._blendBuffer = new z(t, i), this.updateUniforms(s);
+  }
+  /**
+   * The number of blur passes to perform. More passes are expensive but result in stronger blurs and less artifacts.
+   * @returns number
+   */
+  get passes() {
+    return this._blurEffect.passes;
+  }
+  /**
+   * @param {number} value
+   */
+  set passes(t) {
+    this._blurEffect.passes = t;
+  }
+  /**
+   * Sets the size of the effect.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._blurEffect.setSize(t, i), this._blendBuffer.setSize(t, i);
+  }
+  /**
+   * Returns the current uniforms for the effect.
+   * @returns Uniforms
+   */
+  getUniforms() {
+    const { size: t } = this._blendEffect.getUniforms();
+    return { ...this._blurEffect.getUniforms(), size: t };
+  }
+  /**
+   * Updates the specified uniforms for the effect.
+   * @param {Uniforms} uniforms
+   */
+  updateUniforms(t = {}) {
+    const i = this._blendEffect.getUniforms(), { size: s = i.size, ...o } = t;
+    this._blurEffect.updateUniforms(o), this._blendEffect.updateUniforms({ size: s });
+  }
+  /**
+   * Resets the uniforms for the effect back to its default values.
+   */
+  clearUniforms() {
+    this._blurEffect.clearUniforms(), this._blendEffect.clearUniforms();
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    this._blurEffect.render(t, this._blendBuffer, s, o), this._blendEffect.render(t, i, s, this._blendBuffer);
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._blurEffect.dispose(), this._blendEffect.dispose(), this._blendBuffer.dispose();
+  }
+}
+class oe {
+  /**
+   * Constructs a GlitchEffect.
+   * @param {number} width
+   * @param {number} height
+   * @param {Uniforms} uniforms - uniforms for the shader.
+   */
+  constructor(t, i, s = {}) {
+    this._resolution = new T(t, i), this._glitchEffect = new R(nt), this._blurEffect = new W(t, i, { radius: 3 }), this._blurEffect.passes = 2, this._blurBuffer = new z(t, i), this.updateUniforms(s);
+  }
+  /**
+   * Sets the size for the effect.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._resolution.set(t, i), this._blurEffect.setSize(t, i), this._blurBuffer.setSize(t, i);
+  }
+  /**
+   * Returns the current uniforms for the effect.
+   * @returns Uniforms
+   */
+  getUniforms() {
+    return this._glitchEffect.getUniforms();
+  }
+  /**
+   * Updates the specified uniforms for the effect.
+   * @param {Uniforms} uniforms
+   */
+  updateUniforms(t = {}) {
+    this._glitchEffect.updateUniforms(t);
+  }
+  /**
+   * Resets the uniforms for the effect back to its default values.
+   */
+  clearUniforms() {
+    this._glitchEffect.clearUniforms();
+  }
+  /**
+   * Renders the effect.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   * @param {Uniforms} uniforms - uniform values to update before rendering.
+   */
+  render(t, i, s, o = {}) {
+    this._blurEffect.render(t, this._blurBuffer, s), this._glitchEffect.render(t, i, s, this._blurBuffer, {
+      ...o,
+      resolution: this._resolution
+    });
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._glitchEffect.dispose(), this._blurEffect.dispose(), this._blurBuffer.dispose();
+  }
+}
+class at extends X {
+  /**
+   * Constructs an EffectPass.
+   * @param {number} width
+   * @param {number} height
+   */
+  constructor(t, i) {
+    super(), this._copyShader = new O(Ft), this._effects = {}, this._width = t, this._height = i, this._readBuffer = new z(t, i), this._writeBuffer = new z(t, i), this.enabled = !1;
+  }
+  /**
+   * Sets the size of the EffectPass.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._width = t, this._height = i, this._readBuffer.setSize(t, i), this._writeBuffer.setSize(t, i);
+    for (const s of Object.values(this._effects))
+      s.setSize && s.setSize(t, i);
+  }
+  /**
+   * Returns the configurations for the currently set effects.
+   * @returns EffectConfigs
+   */
+  getConfigs() {
+    const t = {};
+    for (const [i, s] of Object.entries(this._effects))
+      switch (i) {
+        case p.Blur: {
+          const { radius: o } = s.getUniforms();
+          t[i] = { radius: o, passes: s.passes };
+          break;
+        }
+        case p.Bloom: {
+          const { opacity: o, radius: n } = s.getUniforms();
+          t[i] = { opacity: o, radius: n, passes: s.passes };
+          break;
+        }
+        case p.RgbShift: {
+          const { amount: o, angle: n } = s.getUniforms();
+          t[i] = { amount: o, angle: U.radToDeg(n) };
+          break;
+        }
+        case p.Vignette: {
+          const { offset: o, darkness: n } = s.getUniforms();
+          t[i] = { offset: o, darkness: n };
+          break;
+        }
+        case p.VignetteBlur: {
+          const { size: o, radius: n } = s.getUniforms();
+          t[i] = { size: o, radius: n, passes: s.passes };
+          break;
+        }
+        case p.Glitch: {
+          const { amount: o, seed: n } = s.getUniforms();
+          t[i] = { amount: o, seed: n };
+          break;
+        }
+      }
+    return t;
+  }
+  /**
+   * Returns whether a specified effect is currently set.
+   * @param {EffectType} type
+   * @returns boolean
+   */
+  hasEffect(t) {
+    return this._effects.hasOwnProperty(t);
+  }
+  /**
+   * Returns whether any effects are currently set.
+   * @returns boolean
+   */
+  hasEffects() {
+    return Object.getOwnPropertyNames(this._effects).length !== 0;
+  }
+  /**
+   * Returns the current effect for the specified type.
+   * If no effect is currently set for the type, creates a new effect for the type and returns it.
+   * @param {EffectType} type
+   * @param {EffectConfig} config
+   * @returns IEffect
+   */
+  _getEffect(t) {
+    if (!(t in this._effects))
+      switch (t) {
+        case p.Blur:
+          this._effects[t] = new W(this._width, this._height);
+          break;
+        case p.Bloom:
+          this._effects[t] = new te(this._width, this._height);
+          break;
+        case p.RgbShift:
+          this._effects[t] = new ee();
+          break;
+        case p.Vignette:
+          this._effects[t] = new ie();
+          break;
+        case p.VignetteBlur:
+          this._effects[t] = new se(this._width, this._height);
+          break;
+        case p.Glitch:
+          this._effects[t] = new oe(this._width, this._height);
+          break;
+      }
+    return this._effects[t];
+  }
+  /**
+   * Sets an effect. If an effect is already set, updates the set effect.
+   * @param {EffectType} type - the effect to set.
+   * @param {Object} config - configuration specific to the effect specified.
+   */
+  set(t, i = {}) {
+    const s = this._getEffect(t);
+    switch (this.enabled = !0, t) {
+      case p.Blur: {
+        const { radius: o = 1, passes: n = s.passes } = i;
+        s.passes = n, s.updateUniforms({ radius: o });
+        break;
+      }
+      case p.Bloom: {
+        const { opacity: o = 1, radius: n = 1, passes: r = s.passes } = i;
+        s.passes = r, s.updateUniforms({ opacity: o, radius: n });
+        break;
+      }
+      case p.RgbShift: {
+        const { amount: o = 5e-3, angle: n = 0 } = i;
+        s.updateUniforms({ amount: o, angle: U.degToRad(n) });
+        break;
+      }
+      case p.Vignette: {
+        const { offset: o = 1, darkness: n = 1 } = i;
+        s.updateUniforms({ offset: o, darkness: n });
+        break;
+      }
+      case p.VignetteBlur: {
+        const { size: o = 1, radius: n = 1, passes: r = s.passes } = i;
+        s.passes = r, s.updateUniforms({ radius: n, size: o });
+        break;
+      }
+      case p.Glitch: {
+        const { amount: o = 1, seed: n = Math.random() } = i;
+        s.updateUniforms({ amount: o, seed: n });
+        break;
+      }
+    }
+  }
+  /**
+   * Removes a set effect. Returns true if the effect was removed, otherwise false.
+   * @param {EffectType} type - the type of the effect.
+   * @returns boolean
+   */
+  remove(t) {
+    return t in this._effects ? (this._effects[t].dispose(), delete this._effects[t], this.enabled = this.hasEffects(), !0) : !1;
+  }
+  /**
+   * Removes all set effects.
+   */
+  removeAll() {
+    for (const t in this._effects)
+      this._effects[t].dispose(), delete this._effects[t];
+    this.enabled = !1;
+  }
+  /**
+   * Swaps the internal read and write buffers. Should be called each time after rendering an effect.
+   */
+  _swapBuffers() {
+    const t = this._readBuffer;
+    this._readBuffer = this._writeBuffer, this._writeBuffer = t;
+  }
+  /**
+   * Renders the effects.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from.
+   */
+  render(t, i, s) {
+    this._copyShader.render(t, this._readBuffer, s);
+    for (const o of Object.values(this._effects))
+      o.render(t, this._writeBuffer, this._readBuffer), this._swapBuffers();
+    this._copyShader.render(t, this.renderToScreen ? null : i, this._readBuffer);
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._copyShader.dispose(), this._readBuffer.dispose(), this._readBuffer.texture.dispose(), this._writeBuffer.dispose(), this._writeBuffer.texture.dispose(), Object.values(this._effects).forEach((t) => t.dispose());
+  }
+}
+class ne extends at {
+  /**
+   * Constructs a BackgroundEffects object.
+   * @param {number} width
+   * @param {number} height
+   * @param {PerspectiveCamera} camera - a camera for motion blur support
+   * @param {DepthTexture} depthTexture - a depth texture for motion blur support
+   */
+  constructor(t, i, s, o) {
+    super(t, i), this._camera = s, this._depthTexture = o;
+  }
+  /**
+   * Returns the configurations for the currently set effects.
+   * @returns BackgroundEffectConfigs
+   */
+  getConfigs() {
+    const t = super.getConfigs(), i = this._effects[p.MotionBlur];
+    if (i) {
+      const { intensity: s, samples: o } = i.getUniforms();
+      t[p.MotionBlur] = { intensity: s, samples: o };
+    }
+    return t;
+  }
+  /**
+   * Returns the current effect for the specified type.
+   * If no effect is currently set for the type, creates a new effect for the type and returns it.
+   * @param {EffectType} type
+   * @param {EffectConfig} config
+   * @returns IEffect
+   */
+  _getEffect(t) {
+    return t === p.MotionBlur && !(t in this._effects) ? (this._effects[p.MotionBlur] = new Kt(
+      this._camera,
+      this._depthTexture
+    ), this._effects[p.MotionBlur]) : super._getEffect(t);
+  }
+  /**
+   * Sets an effect. If an effect is already set, updates the set effect.
+   * @param {EffectType} type - the effect to set.
+   * @param {Object} config - configuration specific to the effect specified.
+   */
+  set(t, i = {}) {
+    if (t === p.MotionBlur) {
+      this.enabled = !0;
+      const s = this._getEffect(p.MotionBlur), { intensity: o = 1, samples: n = 32 } = i;
+      s.updateUniforms({ intensity: o, samples: n });
+    } else
+      super.set(t, i);
+  }
+}
+const $ = {
+  uniforms: {},
+  vertexShader: `
+
+    attribute float size;
+
+    // a value from 0 to 1 indicating the size of the blend gradient
+    attribute float gradient;
+    varying float v_gradient;
+
+    // a value from 0 to 1 indicating the opacity of the particle
+    attribute float opacity;
+    varying float v_opacity;
+
+    // the color of the particle
+    attribute vec3 color;
+    varying vec3 v_color;
+
+    void main() {
+      v_gradient = gradient;
+      v_opacity = opacity;
+      v_color = color;
+      
+      gl_PointSize = size;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    varying float v_diameter;
+    varying float v_gradient;
+    varying float v_opacity;
+    varying vec3 v_color;
+
+    void main() {
+      float radius = 0.5;
+      float distanceFromCenter = distance(gl_PointCoord, vec2(0.5, 0.5));
+      if (distanceFromCenter > radius) {
+        discard;
+      }
+      gl_FragColor = vec4(v_color, min((radius - distanceFromCenter) / smoothstep(0.0, 1.0, v_gradient * radius), 1.0) * v_opacity);
+    }
+
+  `
+};
+class re {
+  /**
+   * Constructs a Particles object.
+   * @param {number} width
+   * @param {number} height
+   * @param {number} maxDepth - the maximum depth of the particles in world units.
+   */
+  constructor(t, i, s) {
+    this._groups = {}, this._positions = [], this._width = t, this._height = i, this._maxDepth = s;
+    const o = new Y();
+    o.setAttribute("position", new M(0, 3)), o.setAttribute("size", new M(0, 1)), o.setAttribute("gradient", new M(0, 1)), o.setAttribute("opacity", new M(0, 1)), o.setAttribute("color", new M(0, 3)), this._particles = new yt(
+      o,
+      B.createShaderMaterial($)
+    );
+  }
+  /**
+   * Returns the configurations for the currently set particle groups.
+   * @returns ParticleGroupDefinitionMap
+   */
+  getConfigs() {
+    const t = {};
+    for (const i of Object.values(this._groups)) {
+      const { name: s, amount: o, minSize: n, maxSize: r, minGradient: a, maxGradient: f, minOpacity: h, maxOpacity: c, color: v } = i;
+      t[s] = { name: s, amount: o, minSize: n, maxSize: r, minGradient: a, maxGradient: f, minOpacity: h, maxOpacity: c, color: v };
+    }
+    return t;
+  }
+  /**
+   * Returns whether a group of particles is currently moving.
+   * @param {string} name - the name of the particle group.
+   * @returns boolean
+   */
+  isMoving(t) {
+    return this._groups[t]?.positionTransition.isPlaying() ?? !1;
+  }
+  /**
+   * Returns whether a group of particles is currently swaying.
+   * @param {string} name - the name of the particle group.
+   * @returns boolean
+   */
+  isSwaying(t) {
+    return this._groups[t]?.swayTransition.isPlaying() ?? !1;
+  }
+  /**
+   * Generates particles based on a given set of configurations.
+   * @param {ParticleGroupConfig | ParticleGroupConfig[]} config - a single or array of particle group configurations.
+   */
+  generate(t) {
+    this.removeAll(), t = Array.isArray(t) ? t : [t];
+    let i = 0;
+    for (const n of t) {
+      const {
+        name: r,
+        amount: a = 0,
+        minSize: f = 0,
+        maxSize: h = 0,
+        minGradient: c = 0,
+        maxGradient: v = 1,
+        minOpacity: x = 0,
+        maxOpacity: b = 1,
+        color: g = 16777215,
+        smoothing: l = 0.5
+      } = n;
+      for (let d = 0; d < a; ++d) {
+        const _ = -this._width / 2 + Math.random() * this._width, m = -this._height / 2 + Math.random() * this._height, u = this._maxDepth / 4 * Math.random();
+        this._positions.push(_, m, u);
+      }
+      this._groups[r] = {
+        name: r,
+        index: i,
+        amount: a,
+        minSize: f,
+        maxSize: h,
+        minGradient: c,
+        maxGradient: v,
+        minOpacity: x,
+        maxOpacity: b,
+        color: g,
+        smoothing: l,
+        swayOffset: new T(0, 0),
+        positionTransition: new w({ offsetX: 0, offsetY: 0 }),
+        swayTransition: new w({ offsetX: 0, offsetY: 0 })
+      }, i += a;
+    }
+    const s = new Y();
+    s.setAttribute("position", new M(i * 3, 3)), s.setAttribute("color", new M(i * 3, 3)), s.setAttribute("size", new M(i, 1)), s.setAttribute("gradient", new M(i, 1)), s.setAttribute("opacity", new M(i, 1));
+    const o = B.createShaderMaterial($);
+    o.transparent = !0, this._particles.geometry = s, this._particles.material = o;
+  }
+  /**
+   * Removes all particle groups.
+   */
+  removeAll() {
+    for (const t in this._groups)
+      this.sway(t, !1), this.move(t, !1);
+    this._positions = [], this._groups = {}, this._particles.geometry.dispose(), this._particles.material.dispose();
+  }
+  /**
+   * Calculates a new position based off an existing position and optional offset. Will wrap around boundaries.
+   * @param {Vector2} position - the current position.
+   * @param {Vector2} offset - the offset from the current position.
+   * @returns Vector2
+   */
+  _getNewPosition(t, i) {
+    let { x: s, y: o } = i;
+    s %= this._width, o %= this._height;
+    let n = t.x + s, r = t.y + o;
+    const a = this._width / 2, f = this._height / 2;
+    return Math.abs(t.x + s) > a && (n = s > 0 ? -a + (t.x + s - a) % this._width : a - (Math.abs(t.x + s) - a) % this._width), Math.abs(t.y + o) > f && (r = o > 0 ? -f + (t.y + o - f) % this._height : f - (Math.abs(t.y + o) - f) % this._height), new T(n, r);
+  }
+  /**
+   * Updates the internal positions for particles. This does NOT update the attributes of the BufferGeometry.
+   * @param {number} index - the index to start at.
+   * @param {number} amount - the number of particles.
+   * @param {number[]} positions - an array containing the position values to use.
+   * @param {Vector2} offset - an optional offset to apply to all new position values.
+   */
+  _updatePositions(t, i, s, o) {
+    for (let n = t; n < t + i; ++n) {
+      const { x: r, y: a } = this._getNewPosition(new T(s[n * 3], s[n * 3 + 1]), o);
+      this._positions[n * 3] = r, this._positions[n * 3 + 1] = a;
+    }
+  }
+  /**
+   * Moves a group of particles. Cancels any in-progress moves.
+   * @param {string} name - the name of the group to move.
+   * @param {ParticleMoveOffset | boolean} offset - the distance and angle in radians to move.
+   * If a boolean is passed in instead then the move will either continue or stop based on the value.
+   * @param {LoopableTransitionConfig} transition - an optional transition configuration.
+   */
+  move(t, i, s = {}) {
+    const o = this._groups[t], { index: n, amount: r } = o;
+    if (typeof i == "boolean") {
+      i || o.positionTransition.stop();
+      return;
+    }
+    o.positionTransition.stop();
+    const {
+      loop: a = !1,
+      duration: f = 0,
+      easing: h = D.Linear.None,
+      onStart: c = () => ({}),
+      onUpdate: v = () => ({}),
+      onComplete: x = () => ({}),
+      onStop: b = () => ({})
+    } = s, { distance: g, angle: l } = i, d = g * Math.cos(U.degToRad(l)), _ = g * Math.sin(U.degToRad(l));
+    if (f > 0) {
+      const m = this._positions.slice();
+      o.positionTransition = new w({ offsetX: 0, offsetY: 0 }).to({ offsetX: d, offsetY: _ }, f * 1e3).easing(h).onStart(c).onUpdate(({ offsetX: u, offsetY: y }) => {
+        this._updatePositions(n, r, m, new T(u, y)), v();
+      }).onComplete(() => {
+        a && this.move(t, i, s), x();
+      }).onStop(b).start();
+    } else
+      this._updatePositions(n, r, this._positions, new T(d, _));
+  }
+  /**
+   * Sways a group of particles around their current positions. Cancels any in-progress sways.
+   * @param {string} name - the name of the group to sway.
+   * @param {ParticleSwayOffset | boolean} offset - the distances in world units allowed on each axis for swaying.
+   * If a boolean is passed in instead then the sway will either continue or stop based on the value.
+   * @param {LoopableTransitionConfig} transition - optional configuration for a transition.
+   */
+  sway(t, i, s = {}) {
+    const o = this._groups[t], { swayOffset: n } = o;
+    if (typeof i == "boolean") {
+      i || o.swayTransition.stop();
+      return;
+    }
+    o.swayTransition.stop();
+    const {
+      loop: r = !1,
+      duration: a = 0,
+      easing: f = D.Linear.None,
+      onStart: h = () => ({}),
+      onUpdate: c = () => ({}),
+      onComplete: v = () => ({}),
+      onStop: x = () => ({})
+    } = s, { x: b, y: g } = i;
+    o.swayTransition = new w({
+      offsetX: n.x,
+      offsetY: n.y
+    }).to({
+      offsetX: -b + Math.random() * b * 2,
+      offsetY: -g + Math.random() * g * 2
+    }, a * 1e3).easing(f).onStart(h).onUpdate(({ offsetX: l, offsetY: d }) => {
+      n.set(l, d), c();
+    }).onComplete(() => {
+      r && this.sway(t, i, s), v();
+    }).onStop(x).start();
+  }
+  /**
+   * Generates a new random averaged value based off a given value and its range.
+   * @param {number} prevValue - the previous value.
+   * @param {number} minValue - the minimum value for the given value.
+   * @param {number} maxValue - the maximum value for the given value.
+   * @param {number} smoothing - optional amount of smoothing to use as a value between 0 and 1. Defaults to 0.5.
+   * @returns number
+   */
+  _generateNewRandomAveragedValue(t, i, s, o = 0.5) {
+    o = Math.min(o, 0.95);
+    const n = (s - i) / 2, r = Math.max(Math.min(t + (-n + Math.random() * n * 2), s), i), a = t * o + r * (1 - o);
+    return Math.max(Math.min(a, s), i);
+  }
+  /**
+   * Updates the positions of the particles. Should be called on every render frame.
+   */
+  update() {
+    const { attributes: t } = this._particles.geometry, {
+      position: i,
+      size: s,
+      gradient: o,
+      opacity: n,
+      color: r
+    } = t;
+    for (const a of Object.values(this._groups)) {
+      const {
+        index: f,
+        amount: h,
+        minSize: c,
+        maxSize: v,
+        minGradient: x,
+        maxGradient: b,
+        minOpacity: g,
+        maxOpacity: l,
+        color: d,
+        smoothing: _,
+        swayOffset: m
+      } = a;
+      for (let u = f; u < f + h; ++u) {
+        const y = this._getNewPosition(new T(this._positions[u * 3], this._positions[u * 3 + 1]), m), S = new wt(d);
+        i.setXYZ(u, y.x, y.y, this._positions[u * 3 + 2]), r.setXYZ(u, S.r, S.g, S.b), s.setX(u, this._generateNewRandomAveragedValue(s.getX(u), c, v, _)), o.setX(u, this._generateNewRandomAveragedValue(o.getX(u), x, b, _)), n.setX(u, this._generateNewRandomAveragedValue(n.getX(u), g, l, _));
+      }
+    }
+    t.position.needsUpdate = !0, t.size.needsUpdate = !0, t.gradient.needsUpdate = !0, t.opacity.needsUpdate = !0, t.color.needsUpdate = !0;
+  }
+  /**
+   * Returns a three.js object containing the particles.
+   * To use the particles, add this object into a three.js scene.
+   * @returns Points
+   */
+  get object() {
+    return this._particles;
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this.removeAll(), this._particles.geometry.dispose(), this._particles.material.dispose();
+  }
+}
+class N {
+  /**
+   * Constructs a background.
+   * @param {Texture | null} texture
+   * @param {number} width
+   * @param {number} height
+   */
+  constructor(t, i, s) {
+    this._buffer = new z(i, s, { colorSpace: K }), this._buffer.depthTexture = new St(i, s);
+    const o = t && t.image !== void 0 ? t.image.width / t.image.height : 1, n = 1, r = 1 / o;
+    this._plane = new Ut(
+      new Dt(n, r),
+      new Mt({ map: t })
+    ), this.camera = new Vt(this._plane, i, s), this.particles = new re(
+      n * 1.1,
+      r * 1.1,
+      G(this._plane, this.camera.camera, 0)
+    ), this.effects = new ne(
+      i,
+      s,
+      this.camera.camera,
+      this._buffer.depthTexture
+    ), this._scene = new Pt(), this._scene.add(this.particles.object), this._scene.add(this._plane);
+  }
+  /**
+   * Returns the texture of the background.
+   * @returns {Texture | null}
+   */
+  get texture() {
+    return this._plane.material.map;
+  }
+  /**
+   * Sets the size of the background.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this.camera.setSize(t, i), this._buffer.setSize(t, i), this._buffer.depthTexture.image.width = t, this._buffer.depthTexture.image.height = i;
+  }
+  /**
+   * Renders the background.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget | null} writeBuffer - the buffer to render to, or null to render directly to screen.
+   */
+  render(t, i = null) {
+    this.camera.update(), this.particles.update(), t.setRenderTarget(this._buffer), t.render(this._scene, this.camera.camera), this.effects.hasEffects() ? this.effects.render(t, i, this._buffer) : (t.setRenderTarget(i), t.render(this._scene, this.camera.camera));
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._buffer.dispose(), this._buffer.texture.dispose(), this._buffer.depthTexture.dispose(), this._plane.geometry.dispose(), this._plane.material.dispose(), this.camera.dispose(), this.effects.dispose(), this.particles.dispose();
+  }
+}
+class ae extends X {
+  /**
+   * Constructs a BackgroundPass.
+   * @param {Background} background
+   */
+  constructor(t) {
+    super(), this._background = t;
+  }
+  /**
+   * Sets the current background.
+   * @param {Background} background
+   */
+  setBackground(t) {
+    this._background = t;
+  }
+  /**
+   * Returns the current background.
+   * @returns Background
+   */
+  get background() {
+    return this._background;
+  }
+  /**
+   * Sets the size of the current background.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._background.setSize(t, i);
+  }
+  /**
+   * Renders the current background.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget} writeBuffer - the buffer to render to, or null to render directly to screen.
+   */
+  render(t, i) {
+    this._background.render(t, this.renderToScreen ? null : i);
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._background.dispose();
+  }
+}
+const fe = {
+  uniforms: {
+    tDiffuse1: { value: null },
+    tDiffuse2: { value: null },
+    // a value from 0 to 1 indicating the blend ratio for both textures
+    amount: { value: 0 },
+    // the amount value of the previous frame - used to calculate the velocity for the blur
+    prevAmount: { value: 0 },
+    // a positive value that affects the intensity of the blur
+    intensity: { value: 1 },
+    // the number of samples to use (up to 128) - higher samples result in better quality at the cost of performance
+    samples: { value: 32 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  fragmentShader: `
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float prevAmount;
+    uniform float intensity;
+    uniform int samples;
+    varying vec2 vUv;
+
+
+    void main() {
+      vec4 texel = mix(texture2D(tDiffuse1, vUv), texture2D(tDiffuse2, vUv), amount);
+      float velocity = (amount - prevAmount) * intensity;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        float offset = velocity * (float(i) / float(samples - 1) - 0.5);
+        texel += mix(texture2D(tDiffuse1, vec2(vUv.x + offset, vUv.y)), texture2D(tDiffuse2, vec2(vUv.x + offset, vUv.y)), amount);
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `
+};
+var ft = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e[e.Top = 2] = "Top", e[e.Bottom = 3] = "Bottom", e))(ft || {});
+const he = {
+  uniforms: {
+    tDiffuse1: { value: null },
+    tDiffuse2: { value: null },
+    // the number of slides to perform
+    slides: { value: 1 },
+    // a value from 0 to 1 indicating the slide ratio
+    amount: { value: 0 },
+    // the amount value of the previous frame - used to calculate the velocity for the blur
+    prevAmount: { value: 0 },
+    // a positive value that affects the intensity of the blur
+    intensity: { value: 1 },
+    // the direction to slide to
+    direction: {
+      value: 1
+      /* Right */
+    },
+    // the number of samples to use (up to 128) - higher samples result in better quality at the cost of performance
+    samples: { value: 32 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  // TODO: refactor and reduce branching for performance
+  fragmentShader: `
+
+    const int MAX_SAMPLES = 128;
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform int slides;
+    uniform float amount;
+    uniform float prevAmount;
+    uniform float intensity;
+    uniform int direction;
+    uniform int samples;
+    varying vec2 vUv;
+
+    float getComponentForDirection(int direction, vec2 uv) {
+      return direction < 2 ? uv.x : uv.y;
+    }
+
+    vec2 getVectorForDirection(int direction, vec2 uv, float position) {
+      return direction < 2 ? vec2(position, uv.y) : vec2(uv.x, position);
+    }
+
+    float getOffsetPosition(int direction, float uv, float offset) {
+      return direction == 1 || direction == 3
+        ? mod(uv + offset, 1.0)
+        : mod(uv + (1.0 - offset), 1.0);
+    }
+
+    void main() {
+      vec4 texel;
+      float offset = amount * float(slides);
+      float position = getComponentForDirection(direction, vUv);
+
+      bool isFirstSlide = direction == 1 || direction == 3
+        ? position + offset <= 1.0
+        : position - offset >= 0.0;
+
+      if (isFirstSlide) {
+        texel = texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));
+      } else {
+        texel = texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset)));
+      }
+
+      float velocity = (amount - prevAmount) * intensity;
+      for (int i = 1; i < MAX_SAMPLES; ++i) {
+        if (i >= samples) {
+          // hack to allow loop comparisons against uniforms
+          break;
+        }
+        float blurOffset = velocity * (float(i) / float(samples - 1) - 0.5);
+        bool isFirstSlide = direction == 1 || direction == 3
+          ? position + offset + blurOffset <= 1.0
+          : position - offset - blurOffset >= 0.0;
+        if (isFirstSlide) {
+          texel += texture2D(tDiffuse1, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));
+        } else {
+          texel += texture2D(tDiffuse2, getVectorForDirection(direction, vUv, getOffsetPosition(direction, position, offset + blurOffset)));
+        }
+      }
+
+      gl_FragColor = texel / max(1.0, float(samples));
+    }
+
+  `
+};
+var ht = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e[e.Top = 2] = "Top", e[e.Bottom = 3] = "Bottom", e))(ht || {});
+const ce = {
+  uniforms: {
+    tDiffuse1: { value: null },
+    tDiffuse2: { value: null },
+    // a value from 0 to 1 indicating the ratio of the texture wipe
+    amount: { value: 0 },
+    // a value from 0 to 1 indicating the size of the blend gradient
+    gradient: { value: 0 },
+    // the direction to wipe to
+    direction: {
+      value: 1
+      /* Right */
+    },
+    // the angle of the wipe
+    angle: { value: 0 },
+    // the aspect ratio of the texture. required using an angle
+    aspect: { value: 1 }
+  },
+  vertexShader: `
+
+    varying vec2 vUv;
+
+    void main() {
+      vUv = uv;
+      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
+    }
+
+  `,
+  // TODO: refactor and reduce branching for performance
+  fragmentShader: `
+
+    uniform sampler2D tDiffuse1;
+    uniform sampler2D tDiffuse2;
+    uniform float amount;
+    uniform float gradient;
+    uniform int direction;
+    uniform float angle;
+    uniform float aspect;
+    varying vec2 vUv;
+
+    void main() {
+      vec4 texel1 = texture2D(tDiffuse1, vUv);
+      vec4 texel2 = texture2D(tDiffuse2, vUv);
+
+      float position;
+      if (direction == 0) {
+        // WipeDirection.LEFT
+        position = 1.0 - vUv.x;
+      } else if (direction == 1) {
+        // WipeDirection.RIGHT
+        position = vUv.x;
+      } else if (direction == 2) {
+        // WipeDirection.TOP
+        position = vUv.y;
+      } else if (direction == 3) {
+        // WipeDirection.BOTTOM
+        position = 1.0 - vUv.y;
+      }
+
+      float rotationOffset;
+      float rotatedPosition;
+      if (direction < 2) {
+        // rotation for horizontal wipes
+        float slope = 1.0 / tan(angle);
+        rotationOffset = (1.0 / slope) / aspect;
+        rotatedPosition = (vUv.y / slope) / aspect;
+      } else {
+        // rotation for vertical wipes
+        float slope = tan(angle);
+        rotationOffset = slope / aspect;
+        rotatedPosition = (vUv.x * slope) / aspect;
+      }
+
+      // a tween that starts from one side of the texture and ends at the other side.
+      // this tween accounts for offsets due to the size of the blend gradient and angle of the wipe effect.
+      float wipeOffset = (-max(0.0, rotationOffset) - gradient) + ((1.0 + abs(rotationOffset) + gradient) * amount) + rotatedPosition;
+      if (position <= wipeOffset) {
+        gl_FragColor = texel2;
+      } else if (position <= wipeOffset + gradient) {
+        gl_FragColor = mix(texel2, texel1, (position - wipeOffset) / gradient);
+      } else {
+        gl_FragColor = texel1;
+      }
+    }
+
+  `
+};
+var ct = /* @__PURE__ */ ((e) => (e.None = "None", e.Blend = "Blend", e.Blur = "Blur", e.Wipe = "Wipe", e.Slide = "Slide", e.Glitch = "Glitch", e))(ct || {});
+class ue extends X {
+  /**
+   * Constructs a TransitionPass.
+   * @param {Background | null} background
+   * @param {number} width
+   * @param {number} height
+   */
+  constructor(t, i, s) {
+    super(), this._transition = new w({ amount: 0 }), this._transitionEffect = new R(L, { mixRatio: 1 }), this._width = i, this._height = s, this._prevBackground = t ?? new N(null, i, s), this._buffer = new z(i, s), this.enabled = !1;
+  }
+  /**
+   * Sets the size of the TransitionPass.
+   * @param {number} width
+   * @param {number} height
+   */
+  setSize(t, i) {
+    this._width = t, this._height = i, this._prevBackground.setSize(t, i), this._buffer.setSize(t, i);
+  }
+  /**
+   * Returns whether a transition is currently occurring.
+   * @returns boolean
+   */
+  isTransitioning() {
+    return this._transition.isPlaying();
+  }
+  /**
+   * Renders a transition effect over the screen.
+   * @param {Background} background - the background to transition to.
+   * @param {TransitionType} transition - the transition to use.
+   * @param {BackgroundTransitionConfig} config - configuration for the transition.
+   */
+  transition(t, i, s = {}) {
+    const {
+      from: o,
+      to: n,
+      duration: r,
+      delay: a,
+      easing: f,
+      onInit: h,
+      onStart: c,
+      onUpdate: v,
+      onComplete: x,
+      onStop: b
+    } = this._getTweenConfig(t, i, s);
+    this._transition.stop(), h(), this._transition = new w(o).to(n, r).easing(f).onStart(c).onUpdate(v).onComplete(x).onStop(b).delay(a).start();
+  }
+  /**
+   * Sets the internal transition effect to be used.
+   * @param {Shader} shader - a shader definition.
+   * @param {Uniforms} uniforms - a map that defines the values of the uniforms to be used.
+   */
+  _setTransitionEffect(t, i = {}) {
+    this._transitionEffect.dispose(), this._transitionEffect = new R(t, i);
+  }
+  /**
+   * Returns a tween configuration for the specified transition type.
+   * @param {Background} background - the background to transition to.
+   * @param {TransitionType} transition - the type of the transition.
+   * @param {BackgroundTransitionConfig} config - configuration for the transition.
+   */
+  _getTweenConfig(t, i, s = {}) {
+    const o = () => {
+      this.enabled = !0;
+    }, n = () => {
+      this.enabled = !1, this._prevBackground.dispose(), this._prevBackground = t;
+    }, {
+      easing: r = D.Linear.None,
+      duration: a = 0,
+      delay: f = 0,
+      onInit: h = () => ({}),
+      onStart: c = () => ({}),
+      onUpdate: v = () => ({}),
+      onComplete: x = () => ({}),
+      onStop: b = () => ({}),
+      ...g
+    } = s, l = {
+      from: { amount: 0 },
+      to: { amount: 1 },
+      easing: r,
+      duration: a * 1e3,
+      delay: f * 1e3,
+      onInit: () => h(this._prevBackground, t),
+      onStart: () => {
+        c(this._prevBackground, t), o();
+      },
+      onUpdate: () => v(this._prevBackground, t),
+      onComplete: () => {
+        x(this._prevBackground, t), n();
+      },
+      onStop: () => {
+        b(this._prevBackground, t), n();
+      }
+    };
+    switch (i) {
+      case "None": {
+        const { onStart: d } = l;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(L, { mixRatio: 1 }), d();
+          }
+        };
+      }
+      case "Blend": {
+        const { onStart: d, onUpdate: _ } = l;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(L), d();
+          },
+          onUpdate: ({ amount: m }) => {
+            this._transitionEffect.updateUniforms({ mixRatio: m }), _();
+          }
+        };
+      }
+      case "Wipe": {
+        const { onStart: d, onUpdate: _ } = l, { gradient: m = 0, angle: u = 0, direction: y = ht.Right } = g;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(ce, {
+              gradient: m,
+              angle: U.degToRad(u),
+              direction: y,
+              aspect: this._width / this._height
+            }), d();
+          },
+          onUpdate: ({ amount: S }) => {
+            this._transitionEffect.updateUniforms({ amount: S, aspect: this._width / this._height }), _();
+          }
+        };
+      }
+      case "Slide": {
+        const { onStart: d, onUpdate: _ } = l, { slides: m = 1, intensity: u = 1, samples: y = 32, direction: S = ft.Right } = g;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(he, {
+              slides: m,
+              intensity: u,
+              samples: y,
+              direction: S
+            }), d();
+          },
+          onUpdate: ({ amount: k }) => {
+            const { amount: F } = this._transitionEffect.getUniforms();
+            this._transitionEffect.updateUniforms({ prevAmount: F, amount: k }), _();
+          }
+        };
+      }
+      case "Blur": {
+        const { onStart: d, onUpdate: _ } = l, { intensity: m = 1, samples: u = 32 } = g;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(fe, { intensity: m, samples: u }), d();
+          },
+          onUpdate: ({ amount: y }) => {
+            const { amount: S } = this._transitionEffect.getUniforms();
+            this._transitionEffect.updateUniforms({ prevAmount: S, amount: y }), _();
+          }
+        };
+      }
+      case "Glitch": {
+        const { onStart: d, onUpdate: _ } = l, { seed: m = Math.random() } = g;
+        return {
+          ...l,
+          onStart: () => {
+            this._setTransitionEffect(nt, { seed: m, resolution: new T(this._width, this._height) }), d();
+          },
+          onUpdate: ({ amount: u }) => {
+            const { resolution: y } = this._transitionEffect.getUniforms();
+            y.set(this._width, this._height), this._transitionEffect.updateUniforms({ amount: u }), _();
+          }
+        };
+      }
+      default:
+        return l;
+    }
+  }
+  /**
+   * Renders the transition.
+   * @param {WebGLRenderer} renderer - the renderer to use.
+   * @param {WebGLRenderTarget} writeBuffer - the buffer to render to, or null to render directly to screen.
+   * @param {WebGLRenderTarget} readBuffer - the buffer to read from which contains the current background.
+   */
+  render(t, i, s) {
+    this.isTransitioning() && (this._prevBackground.render(t, this._buffer), this._transitionEffect.render(t, this.renderToScreen ? null : i, this._buffer, s));
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._transition.stop(), this._prevBackground.dispose(), this._buffer.dispose(), this._transitionEffect.dispose();
+  }
+}
+function Se() {
+  return Bt.isWebGL2Available();
+}
+function Ue(e) {
+  return new Promise((t, i) => {
+    new Et().load(
+      e,
+      (s) => {
+        s.wrapS = H, s.wrapT = H, s.minFilter = Ct, s.repeat.set(1, 1), s.colorSpace = K, t(s);
+      },
+      () => ({}),
+      (s) => i(
+        s.error ?? new Error(
+          "Failed to load requested image. Verify CORS policy or check if the image is valid."
+        )
+      )
+    );
+  });
+}
+class De {
+  /**
+   * Constructs a renderer.
+   * @param {HTMLCanvasElement} canvas - the canvas element to use.
+   * @param {BackgroundRendererOptions} options - options for the renderer.
+   */
+  constructor(t, i = {}) {
+    this._clock = new Tt(!1), this._paused = !0, this._disposed = !1;
+    const { clientWidth: s, clientHeight: o } = t;
+    this._renderer = new zt({
+      canvas: t,
+      powerPreference: "high-performance"
+    }), this._renderer.setSize(s, o, !1), this._composer = new Ot(this._renderer), this._background = new N(null, s, o), this._backgroundPass = new ae(this._background), this._transitionPass = new ue(this._background, s, o), this._effectPass = new at(s, o), this._composer.addPass(this._backgroundPass), this._composer.addPass(this._transitionPass), this._composer.addPass(this._effectPass), this._composer.addPass(new It()), this._render = this._render.bind(this);
+    const { autoRender: n = !0 } = i;
+    n && this.render();
+  }
+  /**
+   * Returns the global effects.
+   * Effects set on this will apply to all backgrounds.
+   * @returns EffectPass
+   */
+  get effects() {
+    return this._effectPass;
+  }
+  /**
+   * Returns the current background.
+   * @returns Background
+   */
+  get background() {
+    return this._background;
+  }
+  /**
+   * Returns whether the background is currently transitioning.
+   * @returns boolean
+   */
+  isTransitioning() {
+    return this._transitionPass.isTransitioning();
+  }
+  /**
+   * Sets the current background.
+   * @param {Texture} texture - the image to use for the background.
+   * @param {Transition} transition - optional configuration for a transition.
+   */
+  setBackground(t, i) {
+    const { clientWidth: s, clientHeight: o } = this._renderer.domElement;
+    if (this._background = new N(t, s, o), i) {
+      const {
+        type: n,
+        config: { onStart: r = () => ({}), ...a }
+      } = i;
+      this._transitionPass.transition(this._background, n, {
+        ...a,
+        onStart: (f, h) => {
+          this._backgroundPass.setBackground(h), r(f, h);
+        }
+      });
+    } else
+      this._backgroundPass.setBackground(this._background), this._transitionPass.transition(this._background, ct.None);
+  }
+  /**
+   * Resizes the canvas if necessary. Should be called on every render frame.
+   */
+  _resizeCanvas() {
+    const { width: t, height: i, clientWidth: s, clientHeight: o } = this._renderer.domElement;
+    (t !== s || i !== o) && (this._renderer.setSize(s, o, !1), this._composer.setSize(s, o), this._backgroundPass.setSize(s, o), this._transitionPass.setSize(s, o), this._effectPass.setSize(s, o));
+  }
+  /**
+   * Begins rendering the background.
+   */
+  render() {
+    this._renderAnimationFrame !== void 0 && (cancelAnimationFrame(this._renderAnimationFrame), this._renderAnimationFrame = void 0), this._paused = !1, this._clock.start(), this._render();
+  }
+  /**
+   * Pauses rendering of the background.
+   */
+  pause() {
+    this._paused = !0, this._clock.stop(), this._renderAnimationFrame !== void 0 && (cancelAnimationFrame(this._renderAnimationFrame), this._renderAnimationFrame = void 0);
+  }
+  /**
+   * Returns whether the renderer is paused.
+   * @returns {boolean}
+   */
+  get isPaused() {
+    return this._paused;
+  }
+  /**
+   * Renders the background, transitions, and effects. Should be called on every frame.
+   */
+  _render() {
+    Gt(), this._resizeCanvas(), this._disposed || (this._composer.render(this._clock.getDelta()), this._renderAnimationFrame = requestAnimationFrame(this._render));
+  }
+  /**
+   * Disposes this object. Call when this object is no longer needed, otherwise leaks may occur.
+   */
+  dispose() {
+    this._disposed = !0, this._renderer.dispose(), this._backgroundPass.dispose(), this._transitionPass.dispose(), this._effectPass.dispose(), this._clock.stop();
+  }
+}
+const Me = D;
+export {
+  N as Background,
+  Vt as BackgroundCamera,
+  ne as BackgroundEffects,
+  De as BackgroundRenderer,
+  Me as Easings,
+  at as EffectPass,
+  p as EffectType,
+  re as Particles,
+  ft as SlideDirection,
+  ct as TransitionType,
+  ht as WipeDirection,
+  Se as isWebGLSupported,
+  Ue as loadImage
+};
diff --git a/package.json b/package.json
index 89212b95fa20ad5af3f2e8e59c7acf154b9469d8..11ed31e70a632c4758460d974fe0123b0a64e1b0 100644
--- a/package.json
+++ b/package.json
@@ -2,6 +2,7 @@
   "name": "midori-bg",
   "version": "1.0.3",
   "description": "Animated image backgrounds",
+  "type":"module",
   "license": "MIT",
   "keywords": [
     "background",
@@ -25,11 +26,11 @@
     "url": "https://aeroheim.moe/"
   },
   "main": "./dist/midori.cjs",
-  "module": "./dist/midori.js",
+  "module": "./dist/midori.mjs",
   "types": "./dist/midori.d.ts",
   "files": [
     "/dist/midori.cjs",
-    "/dist/midori.js",
+    "/dist/midori.mjs",
     "/dist/midori.d.ts"
   ],
   "scripts": {
@@ -66,7 +67,7 @@
     "react": "^17.0.1",
     "react-dom": "^17.0.1",
     "rimraf": "^3.0.2",
-    "three": "^0.132.2",
+    "three": "^0.179.1",
     "typescript": "^4.2.3",
     "webpack": "^5.51.2",
     "webpack-cli": "^4.8.0",
@@ -78,6 +79,6 @@
     "@tweenjs/tween.js": "^18.6.4"
   },
   "peerDependencies": {
-    "three": ">=0.132.2"
+    "three": ">=0.152.0"
   }
 }
